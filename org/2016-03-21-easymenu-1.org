#+BEGIN_HTML
---
layout: post
title: A Trivial(-ish) Application - The Beginning of the Journey
comments: true
categories:
  - programming
tags:
  - programming
  - ruby
  - projects
---
#+END_HTML
#+OPTIONS: ^:nil

The main objective of this series is to show the steps and 
struggles to build a _not so simple and not so complex_ application from the ground up until production.
This system will not be a life changer or a startup product, but I hope it will be useful to someone.

Disclaimer: I don't have much experience in the programming world, so you will see some bad practices.
This will be a collaborative project and, if you feel the urge to change something, give a comment or send a pull request.
It's more about the learning process (mine and yours) =).

* Idea

When I was in college, my friend [[https://github.com/pedro-stanaka][Pedro Tanaka ]]had the idea to build an Android app that showed the _menu of our university cafeteria_.
Nothing better to explain the problem that this app solves with a classic rage comic.

[[./res/easymenu/rage-1.png]]

# 1. Derp in the line of the university cafeteria. What is in the menu of the restaurant?
# 2. I'll visit the university website with my 3G connection. 
# 3. After 30 seconds. I can't read this menu to read from my smartphone because it is awful to read.
# 4. FUUUUU

The above situation may happen, but the most common situation is the below:

[[./res/easymenu/rage-2.png]]
# 6. Derp in the line of the cafeteria. What is in the menu of the restaurant?
# 7. OMG. I'm a broke student and I don't have credit data and 3G.
# 8. FUUUUU

To help Derp, this app would scrap the university website to fetch the menu, store this information into the device and _shows the weekly meals without a Internet connection when the user wants_.

_In fact_, we started building it, but due to other obligations, the project _estacionou_...
due to other life obligations.
# the and would show to the user the weekly meals.
# the website, stores the dishes and allows the user to check in the app.
# So, here is the idea of this application:
# Often, this menu is exported from Excel to a web page or it is a pdf that has dishes of the week.
# Usually, there is a homepage that shows the dishes of the current week.

* Architecture

With the initial development of the Android app, 
me and Pedro identified that our app could had a bigger scope and the potential to reach more universities.

We noticed that the only difference, besides the name, between University A and B apps is
the website format and, consequently, the parser code that translates the HTML to the entities of our software. 
Just like StackExchange built _several forum_ based in the same _codebase (Link do atwood)_, 
the same code would fit several universities and the only thing that would change among these apps is the parser component.

Another issue we found with the Android-only approach was related to the maintainance of the parser.
Let's suppose that, in case we wanted to make an iOS app, the logic parser would have to be rewritten in Swift.
Also, web scraping is not really maintainable because anytime the site changes, we would have to update all the projects to support the new _format_.
# the format of the HTML coming from the server can be modified without further notice, so .

Besides those issues, some universities provide its menu in other medias, like a PDF file or twitter posts.
_A little impractical for a cell phone device_, isn't?!.

Archer image
Do you want to build an API?
Because that's how you have to build an API

Providing an API would be a clean solution to these problems, because all the clients would fetch the information in a single place (our server).
All the parsers would sit in a unique code base and, in case of any update of the web page format, 
_it would be reflected to our clients_ immediately without the need to involve Play Store or App Store.

# _To_ The architecture of our system will be something like that:
Our app now would communicate with our API instead of fetching the web site directly.
Besides, the parsers would be _unified in a single place_ and could handle PDF formats or other oddities without a problem.
Anyway, a good API could be something like that.


[[./res/easymenu/diagram.svg]]
# Image of the architecture
# Scheduler - Parser Service - DB
# DB - API - Android - iOS

1. There should be two main components: The parser service
2. The API should read
3. de brinde, ganhamos um web site

Nice!!! The initial idea was to build an Android app that showed the weekly menu for a single university,
but it turned into an API that could reach Android, iOS apps and Smart watches (why not?!).
_xkcd comic_. Pass me the salt

* The Beginning of the Journey

The first decision about the code of our project are the tools we are gonna use.
Since this is a side project and I won't have much time to fiddle around with it, 
we have to prioritize tools that are _simple and easy to use_ (Sorry, Java and _EJB_. Maybe next time).
Off the top of my head, the Ruby ecosystem is a nice choice because it's a concise programming language, has a nice community to back you up and _is one of the languages that does not step into your toes_. 

# Isn't it a little overkill for this little project.
# Yeah. I agree with you. Rails would bring a lot of complexity into the table.
# But, the Ruby world provides a better alternative that fits like a glove to this project and it's called _Sinatra_.
# _Sinatra_ is a web framework and _bla bla bla_
# The most famous and popular HTML reader. It offers Xpath and CSS selector support 

After settling up, we have to match the architecture components with the tools from Ruby. 
Scheduler: _whenever_, _rufus_ or _resque-scheduler_
Parser: Nokogiri
Database: Postgres or Sqlite
Database and Domain Model: The choice is between an ORM (Active Record, Data Mapper) or raw SQL with Poros. 
API: _Rails_ or _Sinatra_.
Web client: Could be a ruby template engine (_Erb_, _Slime_) or a JS application used with Sinatra 
Android and iOS clients: _React Native_ or Java, Swift native clients.

As you can see, Ruby ecosystem is very mature and _more adjectives_
# and _has good community around it_
# The main requirement 
# and the code will be as simple as possible (Sorry, Java. Maybe next time).
# Ruby is easy to understand even if you don't program in ruby.
# I love Ruby. It is a readable and concise language.
# Web application in rails. You should choose Rails.
# To not keep stuff complex, Sinatra is a micro framework _definir melhor sinatra_

* Conclusion

# git commit

# The blog-series is the one that we are following.
# The master branch is pretty advanced and does not follow.

In this post, the motivations and the main idea of an application.

This will be a fun journey and we are just beginning.
In the next posts of this series, I hope to show the code and the paths to write each component.

Thanks very much for reading this. See you in the next post.

