#+BEGIN_EXPORT html 
---
layout: post
title: Converting metro connections to git graph (Improve me)
comments: false
custom_js:
  - http://localhost:8080/prod/main.js
  - ./res/metro/custom.js
categories:
  - programming
tags:
  - clojure
  - subway
styles:
  - "https://fonts.googleapis.com/css?family=Source+Code+Pro"
---
#+END_EXPORT

# When I'm studying a new programming language or library, I always try to make a practical example to learn it.
# These projects can't be so big because they would eventually discourage me
# and not so small to only touch the surface of the tool.

A few years back, I was trying to learn Clojure, had read some books and was looking for an interesting project to apply the knowledge.
Then I remembered the project [[https://github.com/vbarbaresi/MetroGit%0A][MetroGit]] which consists of building a Git graph from the metro system of Paris.
In my opinion, this project is so creative and simple that the original idea could see some improvement.

So, the idea for this project is to build the git graph through shell commands with a *generic* input of lines and stations.
The lines will be branches, commit for stations and connections will be merge commits.

# A single station
# Provide the input with the metro connections and the algorithm will generate all the necessary commands to build it.

# It is based on the quote from [[https://en.wikiquote.org/wiki/Nathaniel_Borenstein][Nathaniel Borenstein]] (Originally seen it on [[https://blog.codinghorror.com/your-favorite-programming-quote/][Coding Horror]]).

# #+BEGIN_QUOTE 
# It should be noted that no ethically-trained software engineer would ever consent to write a *DestroyBaghdad* procedure. 
# Basic professional ethics would instead require him to write a *DestroyCity* procedure, to which Baghdad could be given as a parameter. 
#           -- Nathaniel Borenstein
# #+END_QUOTE

# Only in this case, I ethically would write the *BuildMetroCity* procedure, not *BuildMetroParis*, passing the metro stations and connections as a parameter.

# Lemme show you the journey of how to do this using Clojure

* Illustration of the idea
In a nutshell, we need to transform a bunch of unknown stations and connection to a git graph.

As an example, this piece of [[https://pt.saopaulomap360.com/mapa-metro-sao-paulo][São Paulo]] metro system:
[[./res/metro/metro-sp.png]]

Will generate these shell commands:

#+BEGIN_SRC shell-script :exports result
# República
git checkout --orphan "Red"
git commit --allow-empty -m "República"
git branch -f "Yellow" HEAD

# Anhangabaú
git commit --allow-empty -m "Anhangabaú"

# Luz
git checkout "Yellow"
git commit --allow-empty -m "Luz"
git branch -f "Blue" HEAD

# Sao Bento
git checkout "Blue"
git commit --allow-empty -m "São Bento"

# Sé
git merge --strategy=ours --allow-unrelated-histories \
--no-ff --commit -m "Sé" Red

# Liberdade
git commit --allow-empty -m "Liberdade"

# Pedro II
git checkout "Red"
git commit --allow-empty -m "Pedro II"
#+END_SRC

Which produces the following git graph (~git log --graph --all --pretty=oneline~ command):

[[./res/metro/git-result.png]]

* Rationalization (Improve me)
This idea might seem easy at first, but it brings some complications about how the rules of the algorithm.

1. A git graph is a [[http://eagain.net/articles/git-for-computer-scientists/][Directed *Acyclic* Graph]], so we can't have cycles in the connections.
2. If there is a cycle, we need to remove the *minimum* number of stations.
3. The traversal *should* visit all nodes (stations) *exactly* once

# To build the algorithm, we need to ask some questions
# that the algorithm will have to take into consideration.

# **How to build the graph?**
# - Since a git graphs is a   
# - But can we pick any direction for the lines?
# - If we find any cycles, how do we ?

# **How to traverse the graph?**
# - Can we traverse the graph without taking into account the other near stations?
# - How to traverse the graph to visit all the stations?
# _Never visit the same station more than once._

# # Imagine if we did a simple traversed the graph without taking into account the other stations/commits. 
# # So we need to take in consideration the already "visited" stations to always finish with

# # Create a commit when you find a sole station and merge when we find a station when two or more lines meet.
# # But, it's not so simple because we have to decide how to traverse it.

# **How to create the git commands?**
# - If we find a simple commit, can we simply commit it?
# - When it's a connection, do we simply generate a merge command?

# In the following sections, all those answers will be answered

* Building the DAG without cycles
The first step is to build a directed graph without cycles, which means we'll need to identify cycles and potentially remove some connections.
There is an awesome library called _loom_ which will support the boilerplate graph functions.

# Before starting the traversal, we .
# To achieve that, we need to find and support a foundation
# The first step of the process is to .

# _From the configuration to a loom graph_
# is that stations will be the graph vertex and the edges will be the connections.

# Now that the graph is ready, we could use the navigation algorithm of loom

# predecessors
# successors
# dfs, bfs and the important dag?

# namespace loom it means that i'm talking with the library
# To perform all graph related operations, we're using the [[https://github.com/aysylu/loom.git][loom]] library.
# After we're done we can call all the same operations

** Input data
Defining the input data is the least of our worries. It could be represented as ~json~ or ~xml~. 
But, since we're using Clojure, let's represent as [[https://clojure.github.io/clojure/clojure.edn-api.html][Extensible Data Notation]]. This way, it's not necessary to write extra code to transform data types.

#+BEGIN_SRC clojure :exports result
[{:name "Red", :stations ["A", "C"]},
 {:name "Green", :stations ["B", "C"]}]
#+END_SRC

~name~ is the name of the line and the ~stations~ will contain the station names. 

** Interfaces
#+BEGIN_SRC clojure :exports result
=> (def subway-map
  [{:name "Red", :stations ["A", "C", "D"]}, 
   {:name "Blue", :stations ["B", "C", "E"]}])

=> (def empty-g (loom.graph/digraph))

=> (def g1 (loom.graph/add-nodes empty-g "A" "B" "C"))

=> (def g2 (-> g1
          (loom.attr/add-attr "A" :lines "Blue")
          (loom.attr/add-attr "B" :lines "Blue")
          (loom.attr/add-attr "B" :lines "Blue")))
  
=> (loom.graph/edges g2)
;; (["C" "E"] ["C" "D"] ["B" "C"] ["A" "C"])

=> (loom.graph/successors g2 "C")
;; #{"E" "D"}

=> (loom.attr/attr g2 "C" :lines)
;; ["Red" "Blue"]

=> (loom.alg/dag? g)
;; true
#+END_SRC

** Without cycles
The subway engineers when planning to add new connections don't care if they'll introduce a cycle in their infrastructure (why would they, right?!)
But, for simplicity, let's start with a graph without 

# But, to start let's suppose that we don't have cycles. 
# By the way, the _loom_ library was used to perform the graph boilerplate

#+BEGIN_SRC clojure :exports result
(defn- add-line-information
  [graph stations line-name]
  "Auxiliary function to add the line name to stations"
  (reduce
   (fn [g station]
     (->>
      ;; To not override other lines
      (conj (or (loom.attr/attr g station :lines) []) line-name)
      ;; Add the attribute to the graph
      (loom.attr/add-attr g station :lines)))
   graph
   stations))

(defn build-with-cycles
  [config]
  "Build a graph without worrying about cycles"
  (reduce
   (fn [graph line]
     ;; partition transforms [A B C] into (("C" "B") ("B" "A"))
     (let [connections (partition 2 1 (:stations line))
           ;; add these edges into the graph
           new-graph (apply loom.graph/digraph graph connections)]
       ;; add the line as attributes in the nodes, it works even with connections

       (add-attribute new-graph (:stations line) (:name line))))
   ;; Start with an empty digraph
   (loom.graph/digraph)
   config))
#+END_SRC

This piece of code yields the following graph:
#+BEGIN_SRC clojure :exports result
=> (def config [{:name "Red", :stations ["A", "C"]},
                {:name "Blue", :stations ["B", "C"]}])
=> (def g (build-with-cycles config))

=> (loom.graph/edges g1)
(["B" "C"] ["A" "C"])
=> (loom.graph/nodes g1)
#{"C" "B" "A"}
=> (loom.attr/attr g1 "A" :lines)
["Red"]
=> (loom.attr/attr g1 "C" :lines)
["Red" "Blue"]
#+END_SRC

The violet station is represented as a connection between red and blue.
#+BEGIN_EXPORT html 
<div class="metro-animation">
  <div id="build-1" class="metro-graph"></div>
</div>
#+END_EXPORT

** Reversing connections
# removing connections is the worst possible case

# When we face a cycle, then the easiest way is to remove some.
# But this might  

# Back to the real world, we might have. s
# And the easiest way to do it is simply to remove the connection.
# But we don't wanna lose 

# Since every line runs in both direction.

# What if a new station introduces a cycle?
# Now we have to worry about stations that introduce cycles

# Before we start to remove edges/connections, we could take a less damaging approach.

# Since every line runs in both directions, we can try to reverse the order of the stations and check if we still have cycles.

# _Add graph when the reversal_

#+BEGIN_SRC diff :exports result
- (let [connections (partition 2 1 (:stations line))
+ (let [connections (valid-connection graph line-config)

#+END_SRC

#+BEGIN_SRC clojure :exports result
(defn- reverse-stations
  [connections]
  (map
   (fn [info] [(second info) (first info)])
   (reverse connections)))

(defn- add-connections
  [graph connections]
  (let [new-graph (apply loom.graph/digraph graph connections)]
    (when (loom.alg/dag? new-graph) connections)))

(defn- valid-connection
  [graph line-config]
  (let [line-name (:name line-config)
        connections (partition 2 1 (:stations line-config))]
    (or (add-connections graph connections)
        (add-connections graph (reverse-stations connections)))))
#+END_SRC

By the way, the method ~loom/dag?~ uses a **topological sort**, which takes ~O(E+V)~ to check if there's a cycle in the graph.

#+BEGIN_SRC clojure :exports result
(def config2 [{:name "Red" :stations ["B" "C" "D"]}
              {:name "Blue" :stations ["A" "D" "B"]}]) 
#+END_SRC

#+BEGIN_EXPORT html 
<div class="metro-animation">
  <div id="build-2" class="metro-graph"></div>
</div>
#+END_EXPORT

#+BEGIN_EXPORT html 
<div class="metro-animation">
  <div id="build-3" class="metro-graph"></div>
</div>
#+END_EXPORT

** Removing connections/edges
If even after reversing the station lines, there are still cycles, the last resort is to remove the connections that introduce them.

The algorithm is not too complex and it's based on this [[https://stackoverflow.com/questions/20246417/how-to-detect-if-adding-an-edge-to-a-directed-graph-results-in-a-cycle][stackoverflow answer]].
The idea is to check if a new connection will introduce a cycle. If it does, then that connection is dropped

# It iterates over each connection of a new station and tries to add it to the graph.

# If it introduces a new cycle, the connection is discarded and the source is linked to
# _It incrementally creates a graph with the new station and checks if the cycle exists_.

# The code was kinda hard to understand and it's _here_ if you're more interested.

# In every connection,
# ~O(E * (V + E))~
# It isn't a problem because the graph will few edges since each station (node) can go one step further.
# Didn't worry so much about complexity
# This algorithm behaved well in the New York City map, which is the subway with the most stations,
# and it removed only two connections.

# Albeit being simple, I tested with the New York City, 
# and it removed only two connections

# But you can check the final graph construction algorithm _here_.

# remove the minimum number of edges
# If there are still cycles after reversing, we need to remove *only* the edges that are introducing it in the first place.
# pragmmatic

#+BEGIN_SRC diff :exports result
(or (add-connections graph connections)
-  (add-connections graph (reverse-stations connections)))))
+  (add-connections graph (reverse-stations connections))
+  (connections-without-cycle graph (:stations line-config) line-name))))

#+END_SRC

#+BEGIN_SRC clojure :exports result
(defn- connections-without-cycle
  [graph stations line-name]
  (loop [g graph
         final-stations [(first stations)]
         iteration-stations (rest stations)]

    (if (empty? iteration-stations)
      (partition 2 1 final-stations)

      (let [new-graph
            (loom.graph/digraph g [(last final-stations)
                                   (first iteration-stations)])]
        (if (loom.alg/dag? new-graph)
          (recur new-graph
                 (conj final-stations (first iteration-stations))
                 (rest iteration-stations))

            (recur graph final-stations (rest iteration-stations)))))))
            
#+END_SRC

* Traversal
We have built a good foundation to start the traversal algorithm. 
We have a clear API which loom brings us and we know for a certain that we don't have cycles.

# Now that the loom graph is built, we need to iterate it in order to generate the git commands.
# We have several methods at our disposal, like [[http://aysy.lu/loom/loom.graph.html#var-predecessors][predecessors]] and [[http://aysy.lu/loom/loom.graph.html#var-successors][successors]].

# _merge commands when two lines meet_
# _switch branch when one line finishes_

# The requirements to go from the traversal to the git commands:
# - *All* the stations should be visited *only once*
# - In order to generate a merge command, we need to check if there are any predecessor that was not visited yet.
# - When we finish visiting a line, we need to check if there are other lines that were left behind and continue from there.
  
# Don't worry too much about understanding these requirements because the next sections will cover it step by step.

# Just a quick notice about the animations.
# Don't worry if you notice any cpu spike, I'm not using your browser to mine bitcoins.
# Simply pause the animations after you visualize it and everything will come back to normal.

** Laying out the API
We could take the following approach:

#+BEGIN_SRC  clojure :exports result
(def config [{:name "Red" :stations ["A" "C"]}
             {:name "Blue" :stations ["B" "C"]}])
             
;; Using function to build the loom dag from the input data
(def graph (build-graph config))

;; We can store graph related data as attributes of the vertex
(def state1 (traverse-subway-graph {:graph graph})
;; {:current-node "A" :current-line "Red" :graph graph-1}

(def state2 (traverse-subway-graph state1))
;; {:current-node "B" :current-line "Blue" :graph graph-2}

(def state3 (traverse-subway-graph state2))
;; {:current-node "C" :current-line ("Blue" "Red") :graph graph-3}

;; No more stations to process
(def state4 (traverse-subway-graph state3))
;; nil
#+END_SRC

# When ~nil~ is returned we know for sure that the traversal 
# is done and there are no more stations to visit.
The next sections will handle the implementation of the ~traverse-subway-graph~

** Stations with only one line
The most simple map _layout_ is when there's only one line.
So let's approach it first and then extend it when the connections meet and go away.

#+BEGIN_SRC
Without animation
Red - A B C
#+END_SRC

#+BEGIN_SRC clojure :exports result
(defn traverse-subway-graph
  [state]
  (let [{:keys [graph current-node current-line]} state
        predecessor 
        (find-unvisited-predecessor graph current-node)]
  (cond
    (not (nil? predecessor)
    (traverse-subway-graph 
      (assoc state :current-node predecessor))
  :else
    (assoc state
       :current-line (loom/attributes graph current-node :line)
       :graph (loom/add-attribute graph 
                                  current-node 
                                  :visited true)
#+END_SRC

#+BEGIN_SRC diff :exports result
(defn traverse-subway-graph
  [state]
-  (let [{:keys [graph current-node current-line]} state
+  (let [{:keys [graph current-node current-line end]} state
        predecessor 
        (find-unvisited-predecessor graph current-node)]
+  (cond
+    (not (nil? predecessor)
-    (traverse-subway-graph 
      (assoc state :current-node predecessor))
  :else
    (assoc state
       :current-line (loom/attributes graph current-node :line)
       :graph (loom/add-attribute graph 
                                  current-node 
                                  :visited true)
#+END_SRC


Notice that we always return a new state to the function

#+BEGIN_EXPORT html
<i id="metro-play-button" class="icon-play fa-play"></i>
<div class="metro-animation">
  <div id="graph-simple" class="metro-graph"></div>
  <div id="commands-simple" class="metro-git-container"></div>
</div>
#+END_EXPORT

There's a problem with it so far. 
The algorithm will run indefinitely because we're always returning
We must supply a stop condition
end variable
stop condition
But there's a problem here, we need to find a way to stop it, 
so we need to add a function that finds any successors that were not visited
~find-successors~ and empty?

** Pending stations
Imagine we have this setup
Now there's a problem. What to choose when the connection has a fork
When we have a fork, but there'll be no way to know when to come
We need to add the pending-nodes attribute

** Initial state

#+BEGIN_SRC clojure :exports result
(-> 
  (initial-state)
  (traverse-subway-graph))
#+END_SRC

Algorithm will decide how it should be stored
We can use the 

Check the _code_ of the traversal algorithm

* Git commands
Now we traverse the graph and for each step we generate the 
The hardest part is gone

We could use jgit for it

We have to keep track of where we are using state

Same strategy with traverse-subway-graph
** Single commit

** Merge stations

** Git force with branch

* Bonus: Clojure Seq abstraction
encapsulate the sequence

the same code that is built to create the git commands is used to create these animations. it's amazing
metro-seq is awesome

Advantage of using something like clojure
metro-seq example, employ purity so the algorithms flows nicely

polimorphism is not restricted to object oriented languages.
in clojure a functional language it is achieved with protocols
show how map, count, etc. are all used

_Should I put this here?_
We don't need to worry about performance or memory footprint when creating a new graph every time
because loom uses sets and maps under the hood and Clojure data structures are [[http://hypirion.com/musings/understanding-persistent-vector-pt-1][persistent]], i.e,
_they share almost the same structure_.

* That's it, folks
Big thanks to washington project
check the project in github

the animations are written in clojurescript. the same algorithm that generated
check this link out and see for yourself. 

It's a combination of git, graph and clojure which means I found the perfect way to finally learn Clojure.

sorry about the cpu usage of these animations, i didn't have the time to optimize

to see if the algorithm really works, i tried to test with the bigger subway system of the world
a lot of cycles were introduced, so we always had to check this
also I built a parser of the page and the page introduced a lot of inconsistencies

thanks to washington since I copied some of the git commands from there

nyc subway is the big boss, since it's the larger
currently, there are only _sao paulo_ and _new york city_ implemented, 
open _an issue_ if you would like to include your city in the list 
anyway, thanks for reading this and sorry about the cpu usage of these animations.
