#+BEGIN_EXPORT html
---
layout: post
title: Converting metro connections to git graph (Improve me)
comments: false
custom_js:
  - ./res/metro/metro.js
  - ./res/metro/custom.js
categories:
  - programming
tags:
  - clojure
  - subway
styles:
  - "https://fonts.googleapis.com/css?family=Source+Code+Pro"
---
#+END_EXPORT

#+ATTR_HTML: :target _blank
A few years ago, I was trying to learn Clojure, had read some books and was looking for an interesting project to apply the knowledge.
Then I remembered reading about the project [[https://github.com/vbarbaresi/MetroGit][MetroGit]] which consists of building a Git graph from the metro system of Paris.
In my opinion, this project is so creative that the original idea could be improved.

So, the idea for this project is to build the git graph through shell commands with a *generic* set of lines, stations and connections.
The lines will be represented as branches, stations as commits and connections as merge commits connecting the branches.

* Illustration of the idea
In a nutshell, we need to transform a bunch of dynamic stations and connection to a git graph.

#+ATTR_HTML: :target _blank
As an example, running the algorithm with this piece of [[https://pt.saopaulomap360.com/mapa-metro-sao-paulo][São Paulo]]
metro system would generate the following shell commands:
[[./res/metro/metro-sp.png]]

#+BEGIN_SRC shell-script :exports result
# República
git checkout --orphan "Red"
git commit --allow-empty -m "República"
git branch -f "Yellow" HEAD

# Anhangabaú
git commit --allow-empty -m "Anhangabaú"

# Luz
git checkout "Yellow"
git commit --allow-empty -m "Luz"
git branch -f "Blue" HEAD

# Sao Bento
git checkout "Blue"
git commit --allow-empty -m "São Bento"

# Sé
git merge --strategy=ours --allow-unrelated-histories \
--no-ff --commit -m "Sé" Red

# Liberdade
git commit --allow-empty -m "Liberdade"

# Pedro II
git checkout  "Red"
git commit --allow-empty -m "Pedro II"
#+END_SRC

Which produces the following git graph from ~git log --graph --all --pretty=oneline~ command:

[[./res/metro/git-result.png]]

_Improve me_
# The next sections are gonna focus on each
# break down the components
To make this process less overwhelming, the rest of the post
is gonna be broken down into these sections:
1. Build the graph from the input data
2. Traverse the graph with the required constraints
3. Generate the git commands while traversing the graph
4. Improve the api with some Clojure magic

# This idea brings some complications regarding the constraints of this algorithm.
# 2. If there is a cycle, we need to remove the *minimum* number of stations.
# 3. The traversal needs to take into account the correct visitation order to build the correct git commands

* Build the DAG
#+ATTR_HTML: :target _blank
A git graph is a [[http://eagain.net/articles/git-for-computer-scientists/][Directed *Acyclic* Graph]], which means that we're gonna
build a graph with directions from stations and connections and remove the *minimum* number of cycles when needed.

** Input data format
#+ATTR_HTML: :target _blank
# Since Clojure is being used, let's represent this data in the [[https://clojure.github.io/clojure/clojure.edn-api.html][Extensible Data Notation (EDN)]].
# This way, it's not necessary to write extra code to transform between data types.

The data format is gonna be an array of lines that contains the stations.
#+BEGIN_SRC clojure :exports result
=> (def config [{:name "Red", :stations ["A", "C"]},
                {:name "Green", :stations ["B", "C"]}])

=> (:name (first config))
"Red"
=> (:stations (first config))
["A" "C"]
#+END_SRC

By the way, some fictitious lines with colors and stations represented as letters.

** graph abstraction with loom library
#+ATTR_HTML: :target _blank
For Clojure(script), there is an awesome library called [[https://github.com/aysylu/loom][loom]], which provides an exceptional API to work with graphs.
Here are some examples:
# It's gonna be the foundation of the project

#+BEGIN_SRC clojure :exports result
;; Create the graph with the connections
=> (def g1 (loom.graph/digraph ["A" "B"] ["B" "C"]))

;; Add the line name as an attribute of the node
=> (def g2 (-> g1
              (loom.attr/add-attr "A" :lines ["Blue"])
              (loom.attr/add-attr "B" :lines ["Blue"])
              (loom.attr/add-attr "C" :lines ["Blue" "Red"])))

=> (loom.graph/edges g2)
(["B" "C"] ["A" "B"])

=> (loom.graph/successors g2 "B")
#{"C"}

=> (loom.graph/predecessors g2 "B")
#{"A"}

=> (loom.attr/attr g2 "C" :lines)
["Blue" "Red"]

=> (loom.alg/dag? g2)
true
#+END_SRC

** Without cycles
_Just to familiarize ourselves_, this section is gonna focus exclusively on connections without cycles.
# In the planning phase of the new stations,
# the subway engineers don't care if they'll introduce a cycle in their infrastructure (why would they, right?!)

# Let's just start with the simplest case

# But, to start, let's not think about the cycles yet.

#+BEGIN_SRC clojure :exports result
(defn- add-line-information
  [graph stations line-name]
  (reduce
   (fn [g station]
     (let [current-line (or (loom.attr/attr g station :lines) [])]
       (->>
        (conj current-line line-name)
        (loom.attr/add-attr g station :lines))))
   graph
   (set (flatten stations))))

(defn build-graph-without-cycles
  [config]
  "Build a graph without worrying about cycles"
  (reduce
   (fn [graph line-config]
     (let [connections (partition 2 1 (:stations line-config))
           new-graph (apply loom.graph/digraph graph connections)]
       (add-line-information new-graph connections (:name line-config))))
   (loom.graph/digraph)
   config))

=> (def config [{:name "Red", :stations ["A", "C"]},
                {:name "Blue", :stations ["B", "C"]}])
=> (def g (build-graph-without-cycles config))

=> (loom.graph/edges g)
;; (["B" "C"] ["A" "C"])
=> (loom.graph/nodes g)
;;  #{"C" "B" "A"}
=> (loom.attr/attr g "A" :lines)
;; ["Red"]
=> (loom.attr/attr g "C" :lines)
;; ["Red" "Blue"]
#+END_SRC

And it yields the following graph:
#+BEGIN_EXPORT html
<div class="metro-animation">
  <div id="build-1" class="metro-graph"></div>
</div>
#+END_EXPORT

The violet station is a connection between a red and blue station (red + blue = violet).

** Connections reversal
Before removing some connections, a less damaging approach is possible.
Subway lines are bidirectional, which makes sense because
imagine going to work with a subway and not having a way to come back to your home at the end of the day.

So, when introducing a cycle, we could try to reverse the connections of the line that introduced a new cycle.

#+BEGIN_SRC clojure :exports result
(defn- reverse-stations
  [connections]
  (map
   (fn [info] [(second info) (first info)])
   (reverse connections)))

(defn- add-connections
  [graph connections]
  (let [new-graph (apply loom.graph/digraph graph connections)]
    (when (loom.alg/dag? new-graph) connections)))

(defn- valid-connection
  [graph line-config]
  (let [line-name (:name line-config)
        connections (partition 2 1 (:stations line-config))]
    (or (add-connections graph connections)
        (add-connections graph (reverse-stations connections)))))
#+END_SRC

#+BEGIN_SRC diff :exports result
;; in build-without-cycles function
-(defn build-graph-without-cycles
+(defn build-graph-with-reversal

- (let [connections (partition 2 1 (:stations line))
+ (let [connections (valid-connection graph line-config)

#+END_SRC

#+BEGIN_SRC clojure :exports result
=> (def config [{:name "Red" :stations ["B" "C" "D"]}
              {:name "Blue" :stations ["D", "B", "A"]}])

=> (def g (build-graph-with-reversal config))

=> (loom.graph/edges g)
;; (["C" "D"] ["B" "C"] ["B" "D"] ["D" "A"])

=> (loom.graph/predecessors g "D")
;; #{"C" "B"}
#+END_SRC

#+ATTR_HTML: :target _blank
Keep in mind that the call to ~loom.graph/dag?~ does a [[https://en.wikipedia.org/wiki/Topological_sorting][Topological sorting]], which takes ~O(E+V)~.
By the way, ~E~ (edges) are the stations and the ~V~ (vertex) are the connections between them.
Therefore, this algorithm run in ~O(L*(E+V))~ where L is the number of lines,

#+BEGIN_EXPORT html
<div class="metro-animation">
  <div id="build-2" class="metro-graph"></div>
</div>
#+END_EXPORT

Notice that now the ~B~ station connects to the ~D~ station, not ~A~ anymore.

#+BEGIN_EXPORT html
<div class="metro-animation">
  <div id="build-3" class="metro-graph"></div>
</div>
#+END_EXPORT

** Removing connections/edges

If, even after reversing the station lines, there are still cycles, the last resort is to remove the connections that introduced a cycle.
The idea is to check if a new connection is gonna introduce a cycle.
If it does, then the destination station is skipped.

#+BEGIN_SRC diff :exports result
;; in valid-connections function
(or (add-connections graph connections)
-  (add-connections graph (reverse-stations connections)))))
+  (add-connections graph (reverse-stations connections))
+  (connections-without-cycle graph (:stations line-config) line-name))))

#+END_SRC

#+BEGIN_SRC clojure :exports result
(defn- connections-without-cycle
  [graph stations line-name]
  (loop [g graph
         final-stations [(first stations)]
         iteration-stations (rest stations)]

    (if (empty? iteration-stations)
      (partition 2 1 final-stations)

      (let [new-graph
            (loom.graph/digraph g [(last final-stations)
                                   (first iteration-stations)])]
        (if (loom.alg/dag? new-graph)
          (recur new-graph
                 (conj final-stations (first iteration-stations))
                 (rest iteration-stations))

            (recur graph final-stations (rest iteration-stations)))))))

(def config [{:name "Red" :stations ["A" "B" "C" "D" "A"]}])
(def g (build-graph config))
=> (loom.graph/nodes g)
;; #{"C" "B" "A"}
=> (loom.graph/edges g)
;; (["B" "C"] ["A" "B"])
=> (loom.alg/dag? g)
;; true
#+END_SRC

The algorithm is costly ~O(E*(V+E))~ and could be improved,
but we're dealing, at worst case, with thousands of connections and stations, so it's something we should not worry about.
Also, albeit simple, this algorithm behaved well in the New York subway system. It removed only 4 of 496 connections.

#+BEGIN_EXPORT html
<div class="metro-animation">
  <div id="build-4" class="metro-graph"></div>
</div>
#+END_EXPORT

After running the algorithm, the ~D->A~ connection is removed.
#+BEGIN_EXPORT html
<div class="metro-animation">
  <div id="build-5" class="metro-graph"></div>
</div>
#+END_EXPORT

* Traversal
After building the DAGs, it's time to focus on the traversal that's gonna generate the git commands correctly.
We're only focusing on the traversal algorithm and not on the literal command generation in this section.

Now, onto what matters, these are the requirements to go from a generic DAG to a git graph:
- All of the stations should be *marked as visited only once* (no duplicated commits)
- The station can only be marked as visited when it's the *first station* or all of
*their predecessors are already visited* (avoid marking a station as visited and another line has a connection to this station later)
- After the station is marked as visited, *pick its successors* (continue with the next commits)
- After the last station of the line is reached, check other *unvisited stations* (evaluate the other stations on other branches)
- When *all of the stations* are visited, we reach the end of the traversal

Don't feel overwhelmed, it seems complicated, but each condition with a new constraint is gonna be introduced individually.

** A high-level overview of the API
Ideally, we would have a function that abstracts away all these logic requirements.
Each call of the function will return the visited station and its lines and, when ~nil~ is returned, we reach the end of the algorithm.

In a nutshell, here is the higher level view of this API:
#+BEGIN_SRC  clojure :exports result
(def config [{:name "Red" :stations ["A" "C"]}
             {:name "Blue" :stations ["B" "C"]}])

(def graph (build-graph config))

(def state1 (traverse-graph {:graph graph})
;; {:current-node "A" :current-line "Red" :graph graph-1}

(def state2 (traverse-graph state1))
;; {:current-node "B" :current-line "Blue" :graph graph-2}

(def state3 (traverse-graph state2))
;; {:current-node "C" :current-line ("Blue" "Red") :graph graph-3}

;; No more stations to process
(def state4 (traverse-graph state3))
;; nil
#+END_SRC

The next sections implement the ~traverse-subway-graph~ function.

** Single line with individual stations
Let's start with the simplest case. A subway system with only one line and not worrying about successors and predecessors.

#+BEGIN_EXPORT html
<div class="metro-animation">
  <div id="alg-1" class="metro-graph"></div>
</div>
#+END_EXPORT

#+BEGIN_SRC clojure :exports result
(defn- lines
  [graph node]
  (loom.attr/attr graph node :lines))

  (defn traverse-graph-single-line
  [state]
  (let [{:keys [graph current-node current-line]} state]
      (assoc state
             :current-line (lines graph current-node)
             :graph (loom.attr/add-attr graph current-node :visited true))))

(def config [{:name "Green" :stations ["A" "B" "C"]}])
(def g (build-graph config))

=> (def state1 (traverse-graph-single-line {:graph g :current-node "B"}))
;; {:current-node "B", :current-line ["Green"]}
=> (def state2 (traverse-graph-single-line state1))
;; {:current-node "B", :current-line ["Green"]}
#+END_SRC

#+BEGIN_EXPORT html
<i id="alg-2-button" class="icon-play fa-play"></i>
<div class="metro-animation">
  <div id="alg-2" class="metro-graph"></div>
</div>
#+END_EXPORT

Not so great. It's just returning the same station every time, but we already have an idea of how the _API should behave_.

** Single line with predecessors
The next case is to find the predecessors which weren't visited yet.

#+BEGIN_SRC clojure :exports result
(defn visited?
  [graph station]
  (loom.attr/attr graph station :visited))

(defn find-predecessor
  [graph station]
  "Finds the unvisited predecessors of a station"
  (first (filter
          (fn [p] (not (visited? graph p)))
          (loom.graph/predecessors graph station))))

(defn traverse-graph-single-with-predecessors
  [state]
  (let [{:keys [graph current-node current-line]} state
        predecessor (metro.algorithm/find-predecessor graph current-node)]
    (cond
      (not (nil? predecessor))
      (traverse-graph2 (assoc state :current-node predecessor))

      :else
      (assoc state
             :current-line (metro.graph/lines graph current-node)
             :graph (attr/add-attr graph current-node :visited true)))))

=> (def config [{:name "Green" :stations ["A" "B" "C"]}])
=> (def g (build--graph config))
=> (def state1 (traverse-graph-with-predecessors {:graph g :current-node "B"}))
;; {:current-node "A", :current-line ["Green"]}
=> (def state2 (traverse-graph-with-predecessors state1))
;; {:current-node "A", :current-line ["Green"]}
#+END_SRC

#+BEGIN_EXPORT html
<i id="alg-3-button" class="icon-play fa-play"></i>
<div class="metro-animation">
  <div id="alg-3" class="metro-graph"></div>
</div>
#+END_EXPORT

We're having progress. The algorithm now is at least returning to the initial station

** Single line with successors
Now, it's time to add the condition that, if the current node is visited, the successors should be evaluated.

#+BEGIN_SRC clojure :exports result
(defn find-successors
  [graph node]
  (filter
   (fn [s] (not (visited? graph s)))
          (loom.graph/successors graph node)))

(defn traverse-graph-with-successors
  [state]
  (let [{:keys [graph current-node current-line]} state
        predecessor (metro.algorithm/find-predecessor graph current-node)
        successors (metro.algorithm/find-successors graph current-node)]
    (cond
      (not (nil? predecessor))
      (traverse-graph-3 (assoc state :current-node predecessor))

      (and (metro.algorithm/visited? graph current-node) (seq successors))
      (traverse-graph-3 (assoc state :current-node (first successors)))

      :else
      (assoc state
             :current-line (metro.graph/lines graph current-node)
             :graph (loom.attr/add-attr graph current-node :visited true)))))

=> (def config [{:name "Green" :stations ["A" "B" "C"]}])
=> (def g (build--graph config))
=> (def state1 (traverse-graph-with-successors {:graph g :current-node "B"}))
;; {:current-node "A", :current-line ["Green"]}
=> (def state2 (traverse-graph-with-successors state1))
;; {:current-node "B", :current-line ["Green"]}
=> (def state3 (traverse-graph-with-successors state2))
;; {:current-node "C", :current-line ["Green"]}
#+END_SRC

#+BEGIN_EXPORT html
<i id="alg-4-button" class="icon-play fa-play"></i>
<div class="metro-animation">
  <div id="alg-4" class="metro-graph"></div>
</div>
#+END_EXPORT

Cool. It worked for a single line, but the algorithm is still not taking into connections and multiple lines.

** Multiple lines
Let's try to run the current state of the algorithm in a configuration with multiple lines

#+BEGIN_EXPORT html
<i id="alg-5-button" class="icon-play fa-play"></i>
<div class="metro-animation">
  <div id="alg-5" class="metro-graph"></div>
</div>
#+END_EXPORT

When we introduce another line, a good point is that, accidentally, we're handling the case of unvisited predecessors.
But, there is still a problem that the remaining stations of other lines are not even considered in the algorithm when some line doesn't have more stations.

To overcome this, we need to introduce a new data structure which will hold the nodes that are still waiting to be visited, the so-called pending nodes.

#+BEGIN_SRC clojure :exports result
(defn traverse-graph-4
  [state]
  (let [{:keys [graph current-node current-line pending-nodes end]} state
        predecessor (find-predecessor graph current-node)
        successors (find-successors graph current-node)]
    (cond
      (and (not (nil? predecessor)))
      (traverse-graph-4 (assoc state :current-node predecessor))

      (and (visited? graph current-node) (seq successors))
      (traverse-graph-4 (assoc state
                                    :current-node (first successors)
                                    :pending-nodes (concat pending-nodes (rest successors))))

      (and (visited? graph current-node) (empty? successors))
      (traverse-graph-4 (assoc state
                                    :current-node (first pending-nodes)
                                    :pending-nodes (rest pending-nodes)))

      :else
      (assoc state
             :pending-nodes (remove #{current-node} pending-nodes)
             :current-line (metro.graph/lines graph current-node)
             :graph (attr/add-attr graph current-node :visited true)))))


=> (def config [{:name "Green" :stations ["A", "B", "C"]},
             {:name "Red" :stations ["D", "B", "E"]}])
=> (def g (metro.blog/build-graph config))

=> (def state1 (metro.blog/traverse-graph4 {:graph g :current-node "B"}))
;; {:current-node "A", :pending-nodes (), :current-line ["Green"]}
=> (def state2 (metro.blog/traverse-graph4 state1))
;; {:current-node "D", :pending-nodes (), :current-line ["Red"]}
=> (def state3 (metro.blog/traverse-graph4 state2))
;; {:current-node "B", :pending-nodes (), :current-line ["Red" "Green"]}
=> (def state4 (metro.blog/traverse-graph4 state2))
;; {:current-node "E", :pending-nodes ("C"), :current-line ["Red"]}
=> (def state5 (metro.blog/traverse-graph4 state2))
;; {:current-node "E", :pending-nodes (), :current-line ["Green"]}
#+END_SRC

With this result, notice how after green line finishes, we also take the other stations of the red line into account.

#+BEGIN_EXPORT html
<i id="alg-6-button" class="icon-play fa-play"></i>
<div class="metro-animation">
  <div id="alg-6" class="metro-graph"></div>
</div>
#+END_EXPORT

** Finish him
All the recursive algorithms need a stop case, otherwise, they run indefinitely.
For this case, when the line doesn't have more stations to visit or no more pending stations,
we add the key ~end~ to that state. In the next iteration, ~nil~ is returned.

#+BEGIN_SRC clojure :exports result
(defn traverse-graph6
  [state]
  (let [{:keys [graph current-node current-line pending-nodes end]} state
        predecessor (find-predecessor graph current-node)
        successors (find-successors graph current-node)]
    (cond
      end nil

      (and (not (nil? predecessor)))
      (traverse-graph6 (assoc state :current-node predecessor))

      (and (visited? graph current-node) (seq successors))
      (traverse-graph6 (assoc state
                              :current-node (first successors)
                              :pending-nodes (concat pending-nodes (rest successors))))

      (and (visited? graph current-node) (empty? successors))
      (traverse-graph6 (assoc state
                              :current-node (first pending-nodes)
                              :pending-nodes (rest pending-nodes)))

      (and (empty? successors) (empty? pending-nodes))
      (assoc state
             :current-line (metro.graph/lines graph current-node)
             :graph (loom.attr/add-attr graph current-node :visited true)
             :end true)

      :else
      (assoc state
             :pending-nodes (remove #{current-node} pending-nodes)
             :current-line (metro.graph/lines graph current-node)
             :graph (loom.attr/add-attr graph current-node :visited true)))))

(def config [{:name "Red" :stations ["A" "B" "C"]}])
(def graph (build-graph config))
(def state1 (traverse-subway-graph {:graph graph})
;; {:current-node "A" :current-line '("Red") :pending-nodes ()}
(def state2 (traverse-subway-graph state1))
;; {:current-node "B" :current-line '("Red") :pending-nodes ()}
(def state3 (traverse-subway-graph state2))
;; {:current-node "C" :current-line '("Red") :pending-nodes ()}
(def state4 (traverse-subway-graph state3))
;; nil
#+END_SRC

** Tiny API improvement
Instead of having to send the ~current-node~ and the graph every time, we can encapsulate that logic into its own function.

#+BEGIN_SRC clojure :exports result
(defn initial-state
  [graph]
  (let [station (first (loom.graph/nodes graph))]
    {:graph graph
     :pending-nodes ()
     :current-node station
     :current-line (lines graph station)}))

(def config [{:name "Red" :stations ["A" "B" "C"]}])
(def graph (build-graph config))
(def initial-state (initial-state config))
(def state1 (traverse-graph initial-state))
#+END_SRC

* Generate git commands
The last piece of the puzzle is to create *one or more git commands* for each new iterated station in the traversal.

The rules of this algorithm with a station with a single line are:
1. When ~HEAD~ is pointing to the line of the station, simply create the ~commit~ with the station as the message.
2. If ~HEAD~ is not pointing to the branch but the branch exists, do a ~checkout~ followed by a ~commit~.
3. When the line doesn't have a branch yet, a new branch is created without ancestors (~checkout --orphan~) followed by a ~commit~.

When a station has a connection:
1. If, at least two branches (lines) are coming from a different commit (station), create a ~merge commit~
with the name of the station and move all of the other branches to this commit.
2. When all the branches are pointing to the same commit,
we generate a normal commit and then move the other branches (~branch -f~) to point to this new commit.

A challenge that this algorithm imposes is that we need to update where ~HEAD~ is pointing for each iteration and
have a notion of the existing branches and their commits.

# Initially, the idea was to use a library (jgit for example) to support the git operations to update a git repository with the new commands.
# But, with this approach, running the algorithms in the browser with Clojurescript would be impossible,
# so I decided to use native data structures to store the ~branches~, ~commits~ and ~HEAD~.

** Single line/branch
Again, starting with the simplest case, which is a single line which yields only ~checkout~ and ~commit~ commands.

#+BEGIN_SRC clojure :exports result
(defn git-checkout
  [branch current-branches]
  ;; current-branches have all the already created branches
  (if (contains? (set current-branches) branch)
    (str "git checkout \"" branch "\"")
    (str "git checkout --orphan \"" branch "\"")))

(defn git-commit
  [commit-name]
  (str "git commit --allow-empty -m \"" commit-name "\""))

  (defn create-git-commands1
  ([commit-name branch]
   (create-git-commands1 {} commit-name branch))

  ([state commit-name branch]
   (let [current-branch (:current-branch state)
         commands (atom [])]

     (if (nil? current-branch)
       (swap! commands conj (git-checkout commit-name branch)))

     (swap! commands conj (git-commit commit-name))

     (assoc state
            :commands (flatten (deref commands))
            :current-branch branch))))

;; The fnction receives only the commit and branches and it's not coupled with the traversal
=> (def state1 (create-git-commands1 "A" '("Blue")))
=> (:commands state1)
;; ("git checkout --orphan \"A\"" "git commit --allow-empty -m \"A\"")
=> (def state2 (create-git-commands1 state1 "B" '("Blue")))
=> (:commands state2)
;; ("git commit --allow-empty -m \"B\"")
=> (def state3 (create-git-commands1 state2 "C" '("Blue")))
=> (:commands state3)
;; ("git commit --allow-empty -m \"C\"")
#+END_SRC

We're changing the variable ~commands~ in two different places of the same function.
The
@@html:<a href="https://clojure.org/reference/atoms" target="_blank">atom</a>@@
construct was introduced to update a value in two different places of the same function,
but it doesn't make our function less immutable or pure.
This
@@html:<a href="https://clojure.org/reference/transients" target="_blank">quote</a>@@
from Rich Hickey explains why this is not a problem.

#+BEGIN_QUOTE
#+BEGIN_EXPORT html
<p>
If a tree falls in the woods, does it make a sound? <br/>
If a pure function mutates some local data in order to produce an immutable return value, is that ok?
</p>
#+END_EXPORT
#+END_QUOTE

#+BEGIN_EXPORT html
<i id="alg-7-button" class="icon-play fa-play"></i>
<div class="metro-animation-git">
  <div id="alg-7" class="metro-graph"></div>
  <div id="alg-7-git" class="metro-git-container"></div>
</div>
#+END_EXPORT

** Multiple branches/lines
With a single connection, we generate only commits and a checkout to create a single branch in the beginning.
But, when dealing with multiple branches, we need to keep track of the existing state of our repository.

*** Emulating a git repository
When multiple lines/branches are involved, we need to keep track of the existing branches and their commits.
Instead of using a git library to fetch this information, we can represent this information as a plain old Clojure map.
Each new call to the algorithm will update the

As discussed previously, it was mentioned that native data structures would be used to hold the state of the repository.
Basically, this means:

#+BEGIN_SRC clojure :exports result
(def repo {:Red "B",
           :Blue "D"})

(def head :Red)
#+END_SRC

In real life, a ~HEAD~ points to a commit,
but our ~HEAD~ can point to a branch
because our algorithm doesn't need this extra complexity.

*** Finding the HEAD
At the beginning of the algorithm, we need to decide if we can stick with the current ~HEAD~.
If the same ~HEAD~ is picked, we can save unnecessaries ~checkout~ commands.

#+BEGIN_SRC clojure :exports result
(defn pick-head
  [current-head repo station-branches]
  (if (and
       (contains? (set station-branches) current-head)
       (contains? (set (keys repo)) current-head))
    current-head
    (first station-branches)))

;; Initial iteration
(def head1 (pick-head nil {} '("Blue")))
=> "Blue"
;; The iterated station has a Red and Blue branch,
;; but only the Blue branch exists in our repo
(def head2 (pick-head head1 {"Blue" "A"} '("Red" "Blue")))
=> "Blue"
;; We're gonna need to switch HEAD
;; because the Blue line is not in the iterated station
(def head3 (pick-head head2 {"Blue" "B" "Red" "B"} '("Red")))
=> "Red"
#+END_SRC

#+BEGIN_EXPORT html
<i id="alg-8-button" class="icon-play fa-play"></i>
<div class="metro-animation-git">
  <div id="alg-8" class="metro-graph"></div>
  <div id="alg-8-git" class="metro-git-container"></div>
</div>
#+END_EXPORT

*** Finding merge branches
When the iterated station has multiple branches and they're pointing to different commits, we generate a merge commit.

That's why we get
#+BEGIN_SRC clojure :exports result
(defn find-merge-branches
  [head repo branches]
  (let [head-station (get repo head)]
    (filter
     (fn [branch]
       (let [branch-station (get repo branch)]
         (and
          (not (nil? branch-station))
          (not= branch-station head-station)
          (not= branch head))))
     branches)))

(find-merge-branches nil {} '("Blue")
=> ()

(find-merge-branches "Blue" {"Blue" "A"} '("Red"))
=> ()

(find-merge-branches "Red" {"Blue" "A" "Red" "C"} '("Red" "Blue"))
=> ("Blue")
#+END_SRC


#+BEGIN_EXPORT html
<i id="alg-9-button" class="icon-play fa-play"></i>
<div class="metro-animation-git">
  <div id="alg-9" class="metro-graph"></div>
  <div id="alg-9-git" class="metro-git-container"></div>
</div>
#+END_EXPORT


*** Finding companion branches
When multiple branches are pointing to the same commit, we can't generate a merge commit
because it's _not permitted by design_.
If you try to do so, git will raise the ~Already up to date~ message

Luckily, the algorithm to identify these cases is really simple.

#+BEGIN_SRC clojure :exports result
(defn find-companion-branches
  [head merging-branches branches]
  (->>
   (set/difference (set branches) (set merging-branches))
   (remove #{head})))

(find-companion-branches "Red" '("B") '())
=> ()
(find-companion-branches "Red" '() '("Red" "Blue"))
=> ("Blue")
#+END_SRC

#+BEGIN_EXPORT html
<i id="alg-10-button" class="icon-play fa-play"></i>
<div class="metro-animation-git">
  <div id="alg-10" class="metro-graph"></div>
  <div id="alg-10-git" class="metro-git-container"></div>
</div>
#+END_EXPORT

*** Fitting the pieces together
Now that we identify and classify both cases, we can fill the gaps with the remaining implementation.

The implementation is mostly the same compared with single lines but adding new constraints that take multiple branches into consideration.

#+BEGIN_SRC clojure :exports result
(defn git-force-branch
  [branches]
  (map (fn [branch] (str "git branch -f \"" branch "\" HEAD")) branches))

(defn git-merge
  [commit-name branches]
  (str "git merge --strategy=ours --allow-unrelated-histories --no-ff --commit -m \""
       commit-name
       "\" "
       (str/join " " branches)))

(defn update-repo
  [repo branches commit-name]
  (into repo (map (fn [branch] {branch commit-name}) branches)))

(defn create-git-commands
  ([commit-name branches]
   (create-git-commands2 {} commit-name branches))

  ([state commit-name branches]
   (let [repo (or (:repo state) {})
         head (:head state)
         commands (atom [])
         new-head (pick-head head repo branches)]

     (if-not (= head new-head)
       (swap! commands conj (git-checkout new-head (keys repo))))

     (let [merging-branches (find-divergent-branches new-head repo branches)
           remaining-branches (find-remaining-branches new-head merging-branches branches)]
       (if (> (count merging-branches) 0)
         (swap! commands conj (git-merge commit-name merging-branches))
         (swap! commands conj (git-commit commit-name)))

       (let [not-head-branches (concat merging-branches remaining-branches)]
         (swap! commands conj (git-force-branch not-head-branches))))

     (assoc state :commands (flatten (deref commands))
            :head new-head
            :repo (update-repo repo branches commit-name)))))

(def config
  [{:name "Green" :stations ["A", "D", "E"]},
   {:name "Red" :stations ["B", "D", "F", "G"]},
   {:name "Blue" :stations ["C", "D", "F", "H"]}])
(def g (build-graph config))

(def alg-state1 (traverse-graph (initial-state g)))
(def git-state1 (create-git-commands (:current-node alg-state1) (:current-line alg-state1)))

(def alg-state2 (traverse-graph alg-state1))
(def git-state2 (create-git-commands git-state1 (:current-node alg-state2) (:current-line alg-state2)))

(def alg-state3 (traverse-graph alg-state2))
(def git-state3 (create-git-commands git-state2 (:current-node alg-state3) (:current-line alg-state3)))

(def alg-state4 (traverse-graph alg-state3))
(def git-state4 (create-git-commands git-state3 (:current-node alg-state4) (:current-line alg-state4)))
(:commands git-state4)
=> ("git merge --strategy=ours --allow-unrelated-histories --no-ff --commit -m \"D\" Red Blue"
    "git branch -f \"Red\" HEAD"
    "git branch -f \"Blue\" HEAD")
(:head git-state4)
=> "Green"
(:repo git-state4)
=> {"Blue" "D", "Red" "D", "Green" "D"}
#+END_SRC

#+BEGIN_EXPORT html
<i id="alg-11-button" class="icon-play fa-play"></i>
<div class="metro-animation-git">
  <div id="alg-11" class="metro-graph"></div>
  <div id="alg-11-git" class="metro-git-container"></div>
</div>
#+END_EXPORT

* API improvements
We all can agree on one thing here: the current way to generating these commands really sucks.
You need to call a lot of boilerplate functions to get the job done.
Also, a lot of internal information, like the state of the algorithm and the git repository, about the algorithm is being exposed in those calls.
The clients of this program are only interested in one thing: generate the git commands to a generic subway system.

Fortunately, Clojure got our back.

It's possible to produce our own custom collection-like by creating a new type using the ~deftype~ function that's gonna extend the ~ISeq~ interface.
In exchange, we need to implement 4 functions:
- *first*: The first element of the iteration when traversing the graph. If there are no more elements, it returns ~nil~.
- *more* for Clojure or *rest* for Clojurescript: Returns the rest of the collection without the first element. Always returns a collection.
- *next*: Returns the next element of the iteration. Same as rest, but returns ~nil~ when there are no more elements.
- *seq*: Transforms the type in a sequence. In this case, our type is already a sequence, so we just return itself.

#+BEGIN_SRC clojure exports result
(declare seq-first seq-rest seq-next)

(deftype MetroGraph [algorithm-state git-state]
  clojure.lang.ISeq
  (first [self] (seq-first algorithm-state git-state))

  (more [self] (seq-rest self))

  (next [self] (seq-next algorithm-state git-state))

  (seq [self] self))

(defn seq-first
  [algorithm-state git-state]
  {:station (:current-node algorithm-state)
   :line (:current-line algorithm-state)
   :commands (:commands git-state)
   :state algorithm-state})

(defn seq-rest
  [self]
  (or (next self) '()))

(defn seq-next
  [algorithm-state git-state]
  (let [new-state (traverse-graph algorithm-state)]
    (when-not (nil? new-state)
      (let [new-git-state (create-git-commands git-state
                                                         (:current-node new-state)
                                                         (:current-line new-state))]
        (MetroGraph. new-state new-git-state)))))

(defn build-seq
  [initial-state]
  (MetroGraph. initial-state
               (metro.git/create-git-commands
                (:current-node initial-state)
                (:current-line initial-state))))

(defn metro-git-seq
  [config]
  (build-seq
   (-> config
       (build-graph)
       (initial-state)
       (traverse-graph))))

(def config [{:name "Red", :stations ["A", "C"]},
                {:name "Green", :stations ["B", "C"]}])
(:commands (first (metro-git-seq config)))

(:line (last (metro-git-seq config)))

(:station (second (metro-git-seq config)))
#+END_SRC

# Now we have a simple,

We now have a simple and encapsulated way of executing the creation and traversal of the graph and generation of the commands.
With this type, we can reuse some ready-made functions, like ~filter~, ~map~ and ~reduce~

# We can use [[https://clojure.org/reference/sequences#_the_seq_library%0A][several functions]]

#+BEGIN_SRC clojure exports result
;; load-from-file not implemented
(def nyc-config (load-from-file "nyc.txt"))
(def nyc-seq (metro-git-seq nyc-config))

;; lines of  New York City
(sort (set (flatten (map :line nyc-seq))))
=> ("1" "2" "3" "4" "5" "6" "7" "A" "B" "C" "D"
    "E" "F" "G" "J" "L" "M" "N" "Q" "R" "W" "Z")

;; Stations that have more than 6 connections
(map :station (filter #(> (count (:line %)) 6) nyc-seq))
=> ("West 4 Street - Washington Square / 6 Avenue"
    "Atlantic Avenue / Barclays Center")

;; Number of merge commits
(count (filter #(str/starts-with? % "git merge") (mapcat :commands nyc-seq)))
=> 62
#+END_SRC

But, the most important part is creating a new file with the git commands.

#+BEGIN_SRC clojure exports result
;; Write the git commands to a file
(spit "nyc.sh" (str/join "\n" (mapcat :commands nyc-seq)))
#+END_SRC

#+BEGIN_SRC shell exports result
mkdir nyc_repo && cd nyc_repo
git init
sh ../nyc.sh

git log --oneline
# 670b346 (HEAD -> M) Forest Avenue / 67 Avenue
# eb8a8e4 Hewes Street / Broadway
# 6a97c04 Lorimer Street / Broadway
# cfddc65 Flushing Avenue / Broadway
# c503053 Kosciuszko Street / Broadway
# 1cb5df7 Halsey Street / Broadway
#+END_SRC

* That's it, folks
Phew. We finally finished the journey of mapping git commands of a subway system.
I hope it was a pleasant experience and you learned something new.

I wanna thank the creators of
@@html:<a href="https://github.com/vbarbaresi/MetroGit" target="_blank">MetroGit</a>@@
(Paris) which I saw the original idea
and
@@html:<a href="https://github.com/bburky/git-dc-metro" target="_blank">git-dc-metro</a>@@
(Washington) which I took the inspiration of the format of the commands =P

#+ATTR_HTML: :target _blank
If you're curious, the code for the project
@@html:<a href="https://github.com/gjhenrique/metro-clojure" target="_blank">metro-clojure</a>@@
 [[][] is in github.
In there, you'll find the complete code of the algorithm and the animations.
If you want to, you can open an issue requesting a new city.

Also, sorry for the CPU usage of the animations. ;)
