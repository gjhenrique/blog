#+BEGIN_EXPORT html
---
layout: post
title: Converting metro connections to git graph (Improve me)
comments: false
custom_js:
  - http://localhost:8080/prod/main.js
  - ./res/metro/custom.js
categories:
  - programming
tags:
  - clojure
  - subway
styles:
  - "https://fonts.googleapis.com/css?family=Source+Code+Pro"
---
#+END_EXPORT

A few years back, I was trying to learn Clojure, had read some books and was looking for an interesting project to apply the knowledge.
Then I remembered the project [[https://github.com/vbarbaresi/MetroGit%0A][MetroGit]] which consists of building a Git graph from the metro system of Paris.
In my opinion, this project is so creative and simple that the original idea could see some improvement.

So, the idea for this project is to build the git graph through shell commands with some sets of lines, stations and connections.
The lines will be represented as branches, stations as stations and connections as merge commits.

To make this process more engaging, the psot was splitted into some core sections:
1. Building the graph from the input data
2. Traversing in a way that's easier
3. Generating the git commands

* Illustration of the idea
In a nutshell, we need to transform a bunch of unknown stations and connection to a git graph.

As an example, this piece of [[https://pt.saopaulomap360.com/mapa-metro-sao-paulo][São Paulo]] metro system:
[[./res/metro/metro-sp.png]]

Will generate these shell commands:

#+BEGIN_SRC shell-script :exports result
# República
git checkout --orphan "Red"
git commit --allow-empty -m "República"
git branch -f "Yellow" HEAD

# Anhangabaú
git commit --allow-empty -m "Anhangabaú"

# Luz
git checkout "Yellow"
git commit --allow-empty -m "Luz"
git branch -f "Blue" HEAD

# Sao Bento
git checkout "Blue"
git commit --allow-empty -m "São Bento"

# Sé
git merge --strategy=ours --allow-unrelated-histories \
--no-ff --commit -m "Sé" Red

# Liberdade
git commit --allow-empty -m "Liberdade"

# Pedro II
git checkout "Red"
git commit --allow-empty -m "Pedro II"
#+END_SRC

Which produces the following git graph (~git log --graph --all --pretty=oneline~ command):

[[./res/metro/git-result.png]]


This idea brings some complications regarding the constraints of this algorithm.

1. A git graph is a [[http://eagain.net/articles/git-for-computer-scientists/][Directed *Acyclic* Graph]], which means we can't have cycles in the connections.
2. If there is a cycle, we need to remove the *minimum* number of stations.
3. The traversal needs to take into account the correct order to build the correct git graph

* Building the graph
The first step is to build a directed graph without cycles, which means we'll need to identify cycles and potentially remove some connections.

** Input data
Defining the input data is the least of our worries. It could be represented as ~json~ or ~xml~.
But, since we're using Clojure, let's represent this data in the [[https://clojure.github.io/clojure/clojure.edn-api.html][Extensible Data Notation]].
This way, it's not necessary to write extra code to transform data types.

#+BEGIN_SRC clojure :exports result
=> (def config [{:name "Red", :stations ["A", "C"]},
                {:name "Green", :stations ["B", "C"]}])

=> (:name (first config))
"Red"
=> (:stations (first config))
["A" "C"]
#+END_SRC

~name~ is the name of the line and the ~stations~ will contain the station names.

** Using loom
For Clojure(script), there is an awesome library called [[https://github.com/aysylu/loom][loom]], which provides an exceptional API to work with graphs.
It's gonna be the foundation of the project

#+BEGIN_SRC clojure :exports result
;; Create the graph with the connections
=> (def g1 (loom.graph/digraph ["A" "B"] ["B" "C"]))

;; Add the line name as an attribute of the node
=> (def g2 (-> g1
              (loom.attr/add-attr "A" :lines ["Blue"])
              (loom.attr/add-attr "B" :lines ["Blue"])
              (loom.attr/add-attr "C" :lines ["Blue" "Red"])))

=> (loom.graph/edges g2)
(["B" "C"] ["A" "B"])

=> (loom.graph/successors g2 "B")
#{"C"}

=> (loom.graph/predecessors g2 "B")
#{"A"}

=> (loom.attr/attr g2 "C" :lines)
["Blue" "Red"]

=> (loom.alg/dag? g2)
true
#+END_SRC

** Without cycles
In the planning phase of the new stations,
the subway engineers don't care if they'll introduce a cycle in their infrastructure (why would they, right?!)
But, for now, let's not think about the cycles.

#+BEGIN_SRC clojure :exports result
(defn- add-line-information
  [graph stations line-name]
  "Auxiliary function to add the line name to stations"
  (reduce
   (fn [g station]
     (->>
      ;; To not override other lines
      (conj (or (loom.attr/attr g station :lines) []) line-name)
      ;; Add the attribute to the graph
      (loom.attr/add-attr g station :lines)))
   graph
   stations))

(defn build-graph
  [config]
  "Build a graph without worrying about cycles"
  (reduce
   (fn [graph line]
     ;; partition transforms [A B C] into (("C" "B") ("B" "A"))
     (let [connections (partition 2 1 (:stations line))
           ;; add these edges into the graph
           new-graph (apply loom.graph/digraph graph connections)]
       ;; add the line as attributes in the nodes, it works even with connections

       (add-attribute new-graph (:stations line) (:name line))))
   ;; Start with an empty digraph
   (loom.graph/digraph)
   config))
#+END_SRC

The following code produces the following result
#+BEGIN_SRC clojure :exports result
=> (def config [{:name "Red", :stations ["A", "C"]},
                {:name "Blue", :stations ["B", "C"]}])
=> (def g (build-graph config))

=> (loom.graph/edges g)
   (["B" "C"] ["A" "C"])
=> (loom.graph/nodes g)
    #{"C" "B" "A"}
=> (loom.attr/attr g "A" :lines)
   ["Red"]
=> (loom.attr/attr g "C" :lines)
   ["Red" "Blue"]
#+END_SRC

This piece of code yields the following graph:
#+BEGIN_EXPORT html
<div class="metro-animation">
  <div id="build-1" class="metro-graph"></div>
</div>
#+END_EXPORT

The violet station is represented as a connection between red and blue.

** Reversing connections
Before start removing some connections, a less damaging approach could be used.
There is an interesting heuristics that subway lines are bidirectional,
so, when introducing a cycle, we could try to reverse the connections of the culprit line.


#+BEGIN_SRC diff :exports result
- (let [connections (partition 2 1 (:stations line))
+ (let [connections (valid-connection graph line-config)

#+END_SRC

#+BEGIN_SRC clojure :exports result
(defn- reverse-stations
  [connections]
  (map
   (fn [info] [(second info) (first info)])
   (reverse connections)))

(defn- add-connections
  [graph connections]
  (let [new-graph (apply loom.graph/digraph graph connections)]
    (when (loom.alg/dag? new-graph) connections)))

(defn- valid-connection
  [graph line-config]
  (let [line-name (:name line-config)
        connections (partition 2 1 (:stations line-config))]
    (or (add-connections graph connections)
        (add-connections graph (reverse-stations connections)))))
#+END_SRC

Keep in mind that the call to ~loom.graph/dag?~ does a [[https://en.wikipedia.org/wiki/Topological_sorting][Topological sorting]], which takes ~O(E+V)~.
By the way, ~E~ (edges) are the stations and the ~V~ (vertex) are the connections between them.
Therefore, this algorithm run in ~O(L*(E+V))~ where L is the number of lines.

#+BEGIN_SRC clojure :exports result
=> (def config [{:name "Red" :stations ["B" "C" "D"]}
              {:name "Blue" :stations ["A" "D" "B"]}])

=> (def g (build-graph config))

=> (loom.graph/edges g)
(["C" "D"] ["B" "C"] ["B" "D"] ["D" "A"])

=> (loom.graph/predecessors g "D")
#{"C" "B"}
#+END_SRC

#+BEGIN_EXPORT html
<div class="metro-animation">
  <div id="build-2" class="metro-graph"></div>
</div>
#+END_EXPORT

Notice that the ~B~ station connects to the ~D~ station.
#+BEGIN_EXPORT html
<div class="metro-animation">
  <div id="build-3" class="metro-graph"></div>
</div>
#+END_EXPORT

** Removing connections/edges
If even after reversing the station lines, there are still cycles, the last resort is to remove the connections that introduced a cycle.

The used algorithm is simple and it's based on this [[https://stackoverflow.com/questions/20246417/how-to-detect-if-adding-an-edge-to-a-directed-graph-results-in-a-cycle][stackoverflow answer]].
The idea is to check if a new connection will introduce a cycle. If it does, then that connection is dropped.

#+BEGIN_SRC diff :exports result
(or (add-connections graph connections)
-  (add-connections graph (reverse-stations connections)))))
+  (add-connections graph (reverse-stations connections))
+  (connections-without-cycle graph (:stations line-config) line-name))))

#+END_SRC

#+BEGIN_SRC clojure :exports result
(defn- connections-without-cycle
  [graph stations line-name]
  (loop [g graph
         final-stations [(first stations)]
         iteration-stations (rest stations)]

    (if (empty? iteration-stations)
      (partition 2 1 final-stations)

      (let [new-graph
            (loom.graph/digraph g [(last final-stations)
                                   (first iteration-stations)])]
        (if (loom.alg/dag? new-graph)
          (recur new-graph
                 (conj final-stations (first iteration-stations))
                 (rest iteration-stations))

            (recur graph final-stations (rest iteration-stations)))))))

#+END_SRC

#+BEGIN_SRC clojure :exports result
(def config [{:name "Red" :stations ["A" "B" "C" "A"]}])
(def g (build-graph config))
=> (loom.graph/nodes g)
#{"C" "B" "A"}
=> (loom.graph/edges g)
(["B" "C"] ["A" "B"])
=>
=> (loom.alg/dag? g)
true
#+END_SRC

The algorithm is costly ~O(E*(V+E))~ and could be improved, but our nodes and vertex are usually small.
In the majority of cases, a station has only one connection, also, most of the stations won't introduce cycles.

Albeit simple, this algorithm behaved well in the New York subway system. It removed only 4 of 496 connections.

#+BEGIN_EXPORT html
<div class="metro-animation">
  <div id="build-4" class="metro-graph"></div>
</div>
#+END_EXPORT

The ~D->A~ connection was removed.
#+BEGIN_EXPORT html
<div class="metro-animation">
  <div id="build-5" class="metro-graph"></div>
</div>
#+END_EXPORT

* Traversal
	
Now that we have the graph builder in place. We can worry about the traversal algorithm.

The traversal algorithm should make the git graph construction possible and has the following characteristics:
- All of the stations should be visited *only* once
- The station can only be marked as visited when it's the first station or all of their predecessors are already visited
- After the station is marked as visited, we should assess its successors (more than one in case of a connection)
- After the last station of the line is reached, we need to check other non visited stations
- When all of the stations are visited, then we reach the end of the traversal.


It seems complicated, but we'll build each condition step by step, so it'll be easy to swallow.

** In search of the correct API
The idea is to have a function that abstracts away all these logic requirements.

Each call of the function will return the current state of the algorithm.
In the next sections, we'll see that we can build from this to build a even more powerful abstraction.

In a nutshell, here is the higher level view of this API:
#+BEGIN_SRC  clojure :exports result
(def config [{:name "Red" :stations ["A" "C"]}
             {:name "Blue" :stations ["B" "C"]}])

;; Using function to build the loom dag from the input data
(def graph (build-graph config))

;; We can store graph related data as attributes of the vertex
(def state1 (traverse-subway-graph {:graph graph})
;; {:current-node "A" :current-line "Red" :graph graph-1}

(def state2 (traverse-subway-graph state1))
;; {:current-node "B" :current-line "Blue" :graph graph-2}

(def state3 (traverse-subway-graph state2))
;; {:current-node "C" :current-line ("Blue" "Red") :graph graph-3}

;; No more stations to process
(def state4 (traverse-subway-graph state3))
;; nil
#+END_SRC

The next sections will handle the implementation of the ~traverse-subway-graph~

** Stations with only one line
Let's start with the simplest case. A subway system with only one line.
# Our algorithm should fit this case for now.

# The most simple map _layout_ is when there's only one line.
# So let's approach it first and then extend it when the connections meet and go away.

#+BEGIN_EXPORT html
<div class="metro-animation">
  <div id="alg-1" class="metro-graph"></div>
</div>
#+END_EXPORT

#+BEGIN_SRC clojure :exports result
(defn- lines
  [graph node]
  (loom.attr/attr graph node :lines))

(defn traverse-subway-graph
  [state]
  "Receiving a map as the values of each state. 
   Does not worry with predecessors or successors"
  (let [{:keys [graph current-node current-line]} state]
      (assoc state
             :current-line (lines graph current-node)
             :graph (attr/add-attr graph current-node :visited true))))
#+END_SRC

#+BEGIN_SRC clojure :exports result
(def config [{:name "Green" :stations ["A" "B" "C"]}]) 
(def g (build--graph config))

=> (def state1 (traverse-subway-graph {:graph g :current-node "B"})) 
{:graph loom_graph, :current-node "B", :current-line ["Green"]}
=> (def state1 (traverse-subway-graph {:graph g :current-node "B"}))
{:graph loom_graph, :current-node "B", :current-line ["Green"]}
#+END_SRC

#+BEGIN_EXPORT html
<i id="alg-2-button" class="icon-play fa-play"></i>
<div class="metro-animation">
  <div id="alg-2" class="metro-graph"></div>
</div>
#+END_EXPORT

Not so great. For now, it's just returning the same station every time, but we already have the basis of how the algorithm should behave.
The next case we should focus is to find the predecessors which weren't visited yet.

#+BEGIN_SRC clojure :exports result
(defn visited?
  [graph station]
  (loom.attr/attr graph station :visited))
  
(defn find-predecessor
  [graph station]
  "Finds the non visited predecessors of station"
  (first (filter
          (fn [p] (not (visited? graph p)))
          (loom.graph/predecessors graph station))))
          
(defn traverse-subway-graph
  [state]
  (let [{:keys [graph current-node current-line]} state
        predecessor (metro.algorithm/find-predecessor graph current-node)]
    (cond
      (not (nil? predecessor))
      (traverse-subway-graph (assoc state :current-node predecessor))

      :else
      (assoc state
             :current-line (metro.graph/lines graph current-node)
             :graph (attr/add-attr graph current-node :visited true)))))
             
#+END_SRC

#+BEGIN_EXPORT html
<i id="alg-3-button" class="icon-play fa-play"></i>
<div class="metro-animation">
  <div id="alg-3" class="metro-graph"></div>
</div>
#+END_EXPORT

It's better that we're returning to the beginning, but we're still not progressing in .
Now, it's time to add the condition that, if the current node is visited, it should visit its successors.

#+BEGIN_SRC clojure :exports result
(defn find-successors
  [graph node]
  (filter
   (fn [s] (not (visited? graph s)))
          (loom.graph/successors graph node)))
          
(defn traverse-subway-graph
  [state]
  (let [{:keys [graph current-node current-line]} state
        predecessor (metro.algorithm/find-predecessor graph current-node)
        successors (metro.algorithm/find-successors graph current-node)]
    (cond
      (not (nil? predecessor))
      (traverse-subway-graph (assoc state :current-node predecessor))

      (and (metro.algorithm/visited? graph current-node) (seq successors))
      (traverse-subway-graph (assoc state :current-node (first successors)))

      :else
      (assoc state
             :current-line (metro.graph/lines graph current-node)
             :graph (attr/add-attr graph current-node :visited true)))))
#+END_SRC

#+BEGIN_EXPORT html
<i id="alg-4-button" class="icon-play fa-play"></i>
<div class="metro-animation">
  <div id="alg-4" class="metro-graph"></div>
</div>
#+END_EXPORT

Cool. It worked for a single line for now, but we're not worried yet with connections.

** Multiple lines
What if we execute the current state of the algorithm with multiple lines:

#+BEGIN_EXPORT html
<i id="alg-5-button" class="icon-play fa-play"></i>
<div class="metro-animation">
  <div id="alg-5" class="metro-graph"></div>
</div>
#+END_EXPORT

When we introduce another line, a good point is that, for free, we're handling the case of non visited predecessors.
But, after all the line is visited, the rest of the stations are not even considered.

We need to add an auxiliary data structure which will hold the pending nodes (stations).

#+BEGIN_SRC clojure :exports result
(defn traverse-subway-graph
  [state]
  (let [{:keys [graph current-node current-line pending-nodes end]} state
        predecessor (find-predecessor graph current-node)
        successors (find-successors graph current-node)]
    (cond
      (and (not (nil? predecessor)))
      (traverse-subway-graph (assoc state :current-node predecessor))

      (and (visited? graph current-node) (seq successors))
      (traverse-subway-graph (assoc state
                                    :current-node (first successors)
                                    :pending-nodes (concat pending-nodes (rest successors))))

      (and (visited? graph current-node) (empty? successors))
      (traverse-subway-graph (assoc state
                                    :current-node (first pending-nodes)
                                    :pending-nodes (rest pending-nodes)))

      :else
      (assoc state
             :pending-nodes (remove #{current-node} pending-nodes)
             :current-line (metro.graph/lines graph current-node)
             :graph (attr/add-attr graph current-node :visited true)))))
#+END_SRC

#+BEGIN_EXPORT html
<i id="alg-6-button" class="icon-play fa-play"></i>
<div class="metro-animation">
  <div id="alg-6" class="metro-graph"></div>
</div>
#+END_EXPORT

** Putting an end to the algorithm
Let's try to run the current code to verify how it's behaving.
In practice, this would mean

#+BEGIN_EXPORT clojure exports: result
(def config [{:name "Red" :stations ["A" "B" "C"]}])
(def graph (build-graph config))
(def state1 (traverse-subway-graph {:graph graph})
;; {:current-node "A" :current-line "Red" :graph graph-1}
(def state2 (traverse-subway-graph state1))
;; {:current-node "B" :current-line "Red" :graph graph-1}
(def state3 (traverse-subway-graph state2))
;; {:current-node "C" :current-line "Red" :graph graph-1}
(def state4 (traverse-subway-graph state3))
;; {:current-node "C" :current-line "Red" :graph graph-1}
;; Ooops. this is not correct
(def state5 (traverse-subway-graph state4))
;; {:current-node "C" :current-line "Red" :graph graph-1}
;; Is this ever going to end?!
#+END_EXPORT

As with all the recursive algorithms, it still doesn't have a stop case and it will run indefinitely.
When the line doesn't have more stations or no more pending stations, we know it's time to finish the algorithm

#+BEGIN_EXPORT diff exports: result
(defn traverse-subway-graph
- (let [{:keys [graph current-node current-line pending-nodes]} state
+ (let [{:keys [graph current-node current-line pending-nodes end]} state
  predecessor (metro.algorithm/find-predecessor graph current-node)
  (cond
+   end nil

+   (and (empty? successors) (empty? pending-nodes))
+      (assoc state
+             :current-line (metro.graph/lines graph current-node)
+             :graph (attr/add-attr graph current-node :visited true)
+             :end true)
#+END_EXPORT

** Improving the interface
Although we have a functional code, 
the API of the function seems weird because the "clients" of this function would have to know the concept of ~state~, ~pending-nodes~ and ~graph~.

The ideal case scenario is to encapsulate this logic into a facade function, with only the initial configuration as the input.

# Now that we have a full functional code
# Now that we defined the.
# Algorithm will decide how it should be stored
# We can use the

#+BEGIN_SRC clojure :exports result
(defun initial-state
  [graph]
  (let [node (first (graph/nodes graph))]
    {:pending-nodes () :current-node node :current-line (metro.graph/lines graph node)}))
  
(defun traverse-graph
  [config]
  (let [graph (build-subway-graph config)
        initial-state (initial-state graph)]
  (traverse-subway-graph initial-state)))
#+END_SRC

Check the _code_ of the traversal algorithm

* Git commands
Now we traverse the graph and for each step we generate the
The hardest part is gone

We could use jgit for it

We have to keep track of where we are using state

Same strategy with traverse-subway-graph
** Single commit

** Merge stations

** Git force with branch

* Clojure Seq abstraction
encapsulate the sequence

the same code that is built to create the git commands is used to create these animations. it's amazing
metro-seq is awesome

Advantage of using something like clojure
metro-seq example, employ purity so the algorithms flows nicely

polimorphism is not restricted to object oriented languages.
in clojure a functional language it is achieved with protocols
show how map, count, etc. are all used

_Should I put this here?_
We don't need to worry about performance or memory footprint when creating a new graph every time
because loom uses sets and maps under the hood and Clojure data structures are [[http://hypirion.com/musings/understanding-persistent-vector-pt-1][persistent]], i.e,
_they share almost the same structure_.

* That's it, folks
Big thanks to washington project
check the project in github

the animations are written in clojurescript. the same algorithm that generated
check this link out and see for yourself.

It's a combination of git, graph and clojure which means I found the perfect way to finally learn Clojure.

sorry about the cpu usage of these animations, i didn't have the time to optimize

to see if the algorithm really works, i tried to test with the bigger subway system of the world
a lot of cycles were introduced, so we always had to check this
also I built a parser of the page and the page introduced a lot of inconsistencies

thanks to washington since I copied some of the git commands from there

nyc subway is the big boss, since it's the larger
currently, there are only _sao paulo_ and _new york city_ implemented,
open _an issue_ if you would like to include your city in the list
anyway, thanks for reading this and sorry about the cpu usage of these animations.
