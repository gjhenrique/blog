#+BEGIN_EXPORT html
---
layout: post
title: Converting metro connections to git graph (Improve me)
comments: false
custom_js:
  - ./res/metro/metro.js
  - ./res/metro/custom.js
categories:
  - programming
tags:
  - clojure
  - subway
styles:
  - "https://fonts.googleapis.com/css?family=Source+Code+Pro"
---
#+END_EXPORT

A few years ago, I was learning Clojure, had read some books and was looking
for an interesting project to practice the learnings.
Then I remembered reading about the project
@@html:<a href="https://github.com/vbarbaresi/MetroGit" target="_blank">MetroGit</a>@@
which consists of building a Git graph from the metro system of Paris.
In my opinion, this project is so creative that the original scope could be extended.

So, the idea of this project is to *generate* the necessary git commands
to build the git graph with a *generic* set of lines, stations and connections.
The branches are represented as lines, commits are stations and merge commits are stations that connect lines.

* Illustration of the idea
In a nutshell, we need to transform a bunch of stations, lines and connections to a git graph.
As an example, running the algorithm with this piece of
@@html:<a href="https://pt.saopaulomap360.com/mapa-metro-sao-paulo" target="_blank">São Paulo</a>@@
metro system would generate the following shell commands:
[[./res/metro/metro-sp.png]]

#+BEGIN_SRC shell-script :exports result
# República
git checkout --orphan "Red"
git commit --allow-empty -m "República"
git branch -f "Yellow" HEAD

# Anhangabaú
git commit --allow-empty -m "Anhangabaú"

# Luz
git checkout "Yellow"
git commit --allow-empty -m "Luz"
git branch -f "Blue" HEAD

# Sao Bento
git checkout "Blue"
git commit --allow-empty -m "São Bento"

# Sé
git merge --strategy=ours --allow-unrelated-histories \
--no-ff --commit -m "Sé" Red

# Liberdade
git commit --allow-empty -m "Liberdade"

# Pedro II
git checkout  "Red"
git commit --allow-empty -m "Pedro II"
#+END_SRC

Which produces the following git graph from ~git log --graph --all --pretty=oneline~ command:

[[./res/metro/git-result.png]]

The next sections are gonna focus on the journey of achieving this and
the following sections are :
1. Build an acyclic graph from the input data
2. Traverse the built graph with the required constraints
3. Generate the git commands while traversing the graph
4. Improve the API with the Clojure ~seq~ abstraction

* Build the acyclic graph
A git graph is a
@@html:<a href="https://eagain.net/articles/git-for-computer-scientists/" target="_blank">Directed <b>Acyclic</b> Graphs</a>@@,
which means that first we need to
build a graph with directions from stations and connections and remove the *minimum* number of cycles if needed.

** Input data format
The data format is gonna be simply an array of lines and its stations.

#+BEGIN_SRC clojure :exports result
=> (def config [{:name "Red", :stations ["A", "C"]},
                {:name "Green", :stations ["B", "C"]}])

=> (:name (first config))
"Red"
=> (:stations (first config))
["A" "C"]
#+END_SRC

By the way, to avoid mental overhead, the fictitious lines are gonna be represented with colors and stations with letters.

** Loom, our fellow graph library
For Clojure(script), there is an awesome library called
@@html:<a href="https://github.com/aysylu/loom" target="_blank">loom</a>@@,
which provides code for creating and manipulating graphs.
Take a look at the examples of some functions we're gonna use in the future.

#+BEGIN_SRC clojure :exports result
;; Create the graph with the connections
=> (def g1 (loom.graph/digraph ["A" "B"] ["B" "C"]))

;; Add the line name as an attribute of the node
=> (def g2 (-> g1
              (loom.attr/add-attr "A" :lines ["Blue"])
              (loom.attr/add-attr "B" :lines ["Blue"])
              (loom.attr/add-attr "C" :lines ["Blue" "Red"])))

=> (loom.graph/edges g2)
(["B" "C"] ["A" "B"])

=> (loom.graph/successors g2 "B")
#{"C"}

=> (loom.graph/predecessors g2 "B")
#{"A"}

=> (loom.attr/attr g2 "C" :lines)
["Blue" "Red"]

=> (loom.alg/dag? g2)
true
#+END_SRC

** Graph without cycles
First of all, let's deal with the easiest type of metro configuration, the one without cycles.

This code doesn't do much. We receive an input data, create a new loom graph
from the connections and store the line as attributes of each station/node.

#+BEGIN_SRC clojure :exports result
(defn- add-line-information
  "Store the lines as attributes of each station"
  [graph stations line-name]
  (reduce
   (fn [g station]
     (let [current-line (or (loom.attr/attr g station :lines) [])]
       (loom.attr/add-attr g station :lines (conj current-line line-name))))
   graph
   (set (flatten stations))))

(defn build-graph-without-cycles
  "Build a new loom graph with the stations as nodes and lines as attributes"
  [config]
  (reduce
   (fn [graph line-config]
     ;; Break the stations ["A" "B" "C"] to [["A" "B"] ["B" "C"]]
     (let [connections (partition 2 1 (:stations line-config))
           ;; Add the connections as edges
           new-graph (apply loom.graph/digraph graph connections)]
       (add-line-information new-graph connections (:name line-config))))
   ;; Initializing reduce function with an empty directed graph
   (loom.graph/digraph)
   config))

=> (def config [{:name "Red", :stations ["A", "C"]},
                {:name "Blue", :stations ["B", "C"]}])
=> (def g (build-graph-without-cycles config))

=> (loom.graph/edges g)
;; (["B" "C"] ["A" "C"])
=> (loom.graph/nodes g)
;;  #{"C" "B" "A"}
=> (loom.attr/attr g "A" :lines)
;; ["Red"]
=> (loom.attr/attr g "C" :lines)
;; ["Red" "Blue"]
#+END_SRC

It yields the following graph:

#+BEGIN_EXPORT html
<div class="metro-animation">
  <div id="build-1" class="metro-graph"></div>
</div>
#+END_EXPORT

The violet station is a connection between a red and blue station.

** Reverse connections as an alternative
Before start removing connections for ciclic graphs, we could try to approach the problem with a less damaging mindset.
As we all know metro lines are bidirectional, which makes sense because
imagine going to work by metro in the morning and having to take a Uber to come back to your home at the end of the day.

So, after adding a new line and checking if it introduces a cycle,
we could try to reverse the connections and check if it worked.

_TODO_ Add reverse-stations
#+BEGIN_SRC clojure :exports result
(defn- connections-without-cycle
  "Check if adding the connections to a graph introduces cycle
   If the graph is a dag, returns the connection, otherwise returns nil"
  [graph connections]
  (let [new-graph (apply loom.graph/digraph graph connections)]
    (when (loom.alg/dag? new-graph) connections)))

(defn- valid-connection
  "Return the connections that has a cycle"
  [graph line-config]
  (let [line-name (:name line-config)
        connections (partition 2 1 (:stations line-config))]
    (or (connections-without-cycle graph connections)
        (connections-without-cycle graph (reverse-stations connections)))))
#+END_SRC

#+BEGIN_SRC diff :exports result
;; in build-without-cycles function
-(defn build-graph-without-cycles
+(defn build-graph-reversal

- (let [connections (partition 2 1 (:stations line))
+ (let [connections (valid-connection graph line-config)

#+END_SRC

#+BEGIN_SRC clojure :exports result
=> (def config [{:name "Red" :stations ["B" "C" "D"]}
              {:name "Blue" :stations ["D", "B", "A"]}])

=> (def g (build-graph-reversal config))

=> (loom.graph/edges g)
;; (["C" "D"] ["B" "C"] ["B" "D"] ["D" "A"])

=> (loom.graph/predecessors g "D")
;; #{"C" "B"}
#+END_SRC

Keep in mind that the call to ~loom.graph/dag?~ represents the most expensive operation of the algorithm.
It does a
@@html:<a href="https://en.wikipedia.org/wiki/Topological_sorting" target="_blank">Topological sorting</a>@@
to tell if the graph is a dag or not.
It takes ~O(E+V)~, where
By the way, ~E~ (edges) are the stations and ~V~ (vertex) are the connections among them.
Therefore, this algorithm run in ~O(Line*(Stations+Connections))~.

#+BEGIN_EXPORT html
<div class="metro-animation">
  <div id="build-2" class="metro-graph"></div>
</div>
#+END_EXPORT

Notice that now the ~B~ station connects to the ~D~ station, not ~A~ anymore.

#+BEGIN_EXPORT html
<div class="metro-animation">
  <div id="build-3" class="metro-graph"></div>
</div>
#+END_EXPORT

** Remove connections/edges
If, even after reversing the station lines, there are still cycles, the last resort is to remove the connection that introduced a cycle.

The idea is to check if there is a cycle in every addition of a connection.
If there is, then the destination station is skipped and the station after the destination is connected, if possible, with the origin station.

#+BEGIN_SRC clojure :exports result
(defn- connections-removing-cycles
  "For each new connection, check if we're introducing a cycle.
   If there is a cycle,
   try to connect the origin station to the next destination"
  [graph stations line-name]
  (loop [g graph
         final-stations [(first stations)]
         iteration-stations (rest stations)]

    (if (empty? iteration-stations)
      (partition 2 1 final-stations)

      (let [new-graph
            (loom.graph/digraph g [(last final-stations)
                                   (first iteration-stations)])]
        (if (loom.alg/dag? new-graph)
          (recur new-graph
                 (conj final-stations (first iteration-stations))
                 (rest iteration-stations))

            (recur graph final-stations (rest iteration-stations)))))))

#+END_SRC

Notice how the removal of the cycle is executed only after trying to revert the connections.

#+BEGIN_SRC diff :exports result
;; in valid-connection function
(or (add-connections graph connections)
-    (add-connections graph (reverse-stations connections)))))
+    (add-connections graph (reverse-stations connections))
+    (connections-removing-cycles graph (:stations line-config) line-name))))

#+END_SRC

#+BEGIN_SRC clojure :exports result
(def config [{:name "Red" :stations ["A" "B" "C" "D" "A"]}])
;; build-graph-with-cycles
(def g (build-graph-with-cycles config))
=> (loom.graph/nodes g)
;; #{"C" "B" "A"}
=> (loom.graph/edges g)
;; (["B" "C"] ["A" "B"])
=> (loom.alg/dag? g)
;; true
#+END_SRC

The algorithm is costly ~O(E*(V+E))~ or ~O(Connections*(Stations+Connection))~ and it's not ideal,
but we're dealing, at worst case, with thousands of connections and stations, so it's something we should not worry about.
For example, this algorithm removed only 4 of 496 connections in the huge New York subway system.

#+BEGIN_EXPORT html
<div class="metro-animation">
  <div id="build-4" class="metro-graph"></div>
</div>
#+END_EXPORT

After running the algorithm, ~D->A~ connection is removed.
#+BEGIN_EXPORT html
<div class="metro-animation">
  <div id="build-5" class="metro-graph"></div>
</div>
#+END_EXPORT

We build the algorithm to build a DAG removing the miminum number of connections.
Now it's time to focus on the traversal of this graph.

* Traversal
# After building the DAG, it's time to focus on the traversal that's gonna generate the git commands correctly.
This section focus only on the traversal algorithm and not the command generation.
It's wise to decouple these two components, otherwise the algorithm gets too messy.

Now, back to business, these are the requirements to perform this traversal without interfering with the construction of the graph:
- All of the stations should be *marked as visited only once* (no duplicated commits)
- The station can only be marked as visited when it's the *first station* or all of *their predecessors are already visited* (once you issue a commit, all of the predecessors should be commited before)
- After the station is marked as visited, *pick its successors* (continue with the next commits)
- After the last station of a certain line is reached, check other *unvisited stations* (evaluate the other stations on other branches)
- When *all of the stations* are visited, we reach the end of the traversal

Don't feel overwhelmed by all of this, it seems complicated, but these constraints are gonna be introduced gradually.

** API of the algorithm
Instead of having an ~Iterator~ or something similar,
the designed API is a function call that receives
a state of current visited station and lines and a graph.
After the processing logic, a new state is returned with the new visited station and the updated loom graph.
When ~nil~ is returned, we reach the end of the algorithm.
This approach is similar to a reducer in the redux universe.

#+BEGIN_SRC  clojure :exports result
(def config [{:name "Red" :stations ["A" "C"]}
             {:name "Blue" :stations ["B" "C"]}])

(def graph (build-graph config))

(def state1 (traverse-graph {:graph graph})
;; {:current-node "A" :current-line "Red" :graph graph-1}

(def state2 (traverse-graph state1))
;; {:current-node "B" :current-line "Blue" :graph graph-2}

(def state3 (traverse-graph state2))
;; {:current-node "C" :current-line ("Blue" "Red") :graph graph-3}

;; No more stations to process
(def state4 (traverse-graph state3))
;; nil
#+END_SRC

The next sections implement the ~traverse-graph~ function.

** Single line with individual stations
Always the simplest case first: a subway configuration with only one line.

#+BEGIN_EXPORT html
<div class="metro-animation">
  <div id="alg-1" class="metro-graph"></div>
</div>
#+END_EXPORT

#+BEGIN_SRC clojure :exports result
(defn- lines
  "Auxiliary function to fetch the lines of a station"
  [graph station]
  (loom.attr/attr graph station :lines))

(defn traverse-graph-single-station
  "Only traverse a single station"
  [state]
  (let [{:keys [graph current-node]} state]
      (assoc state
             :current-line (lines graph current-node)
             ;; Store the visited as atttribute of the station
             :graph (loom.attr/add-attr graph current-node :visited true))))



(def config [{:name "Green" :stations ["A" "B" "C"]}])
(def g (build-graph config))

=> (def state1 (traverse-graph-single-station {:graph g :current-node "B"}))
;; {:current-node "B", :current-line ["Green"]}
=> (def state2 (traverse-graph-single-station state1))
;; {:current-node "B", :current-line ["Green"]}
#+END_SRC

#+BEGIN_EXPORT html
<i id="alg-2-button" class="icon-play fa-play"></i>
<div class="metro-animation">
  <div id="alg-2" class="metro-graph"></div>
</div>
#+END_EXPORT

Not so great yet.
It's just returning the same station every time, but we already have an idea of the shape of the function.

** Single line with predecessors
The next case is to find the unvisited predecessors.
To do so, we recursively try to find a station which doesn't have an unvisited predecessor yet.

#+BEGIN_SRC clojure :exports result
(defn- visited?
  [graph station]
  (loom.attr/attr graph station :visited))

(defn- find-unvisited-predecessor
  [graph station]
  (first (filter
          (fn [p] (not (visited? graph p)))
          (loom.graph/predecessors graph station))))

(defn traverse-graph-with-predecessors
  "Traverse and don't visit if there are unvisited predecessors"
  [state]
  (let [{:keys [graph current-node current-line]} state
        predecessor (find-unvisited-predecessor graph current-node)]
    (cond
      (not (nil? predecessor))
      (traverse-graph-with-predecessors
       (assoc state :current-node predecessor))

      :else
      (assoc state
             :current-line (metro.graph/lines graph current-node)
             :graph (loom.attr/add-attr graph current-node :visited true)))))

=> (def config [{:name "Green" :stations ["A" "B" "C"]}])
=> (def g (build--graph config))
=> (def state1 (traverse-graph-with-predecessors {:graph g :current-node "B"}))
;; {:current-node "A", :current-line ["Green"]}
=> (def state2 (traverse-graph-with-predecessors state1))
;; {:current-node "A", :current-line ["Green"]}
#+END_SRC

#+BEGIN_EXPORT html
<i id="alg-3-button" class="icon-play fa-play"></i>
<div class="metro-animation">
  <div id="alg-3" class="metro-graph"></div>
</div>
#+END_EXPORT

We're having progress. The algorithm now is at least returning to the initial station.

** Single line with successors
Now, it's time to add the condition that, if the current station was already visited, the successors are picked.

_TODO Implement the correct code_
#+BEGIN_SRC clojure :exports result
(defn- visited?
  [graph station]
  (loom.attr/attr graph station :visited))

(defn- find-unvisited-predecessor
  [graph station]
  (first (filter
          (fn [p] (not (visited? graph p)))
          (loom.graph/predecessors graph station))))

(defn traverse-graph-with-predecessors
  "Traverse and don't visit if there are unvisited predecessors"
  [state]
  (let [{:keys [graph current-node current-line]} state
        predecessor (find-unvisited-predecessor graph current-node)]
    (cond
      (not (nil? predecessor))
      (traverse-graph-with-predecessors
       (assoc state :current-node predecessor))

      :else
      (assoc state
             :current-line (metro.graph/lines graph current-node)
             :graph (loom.attr/add-attr graph current-node :visited true)))))

=> (def config [{:name "Green" :stations ["A" "B" "C"]}])
=> (def g (build--graph config))
=> (def state1 (traverse-graph-with-successors {:graph g :current-node "B"}))
;; {:current-node "A", :current-line ["Green"]}
=> (def state2 (traverse-graph-with-successors state1))
;; {:current-node "B", :current-line ["Green"]}
=> (def state3 (traverse-graph-with-successors state2))
;; {:current-node "C", :current-line ["Green"]}
#+END_SRC

#+BEGIN_EXPORT html
<i id="alg-4-button" class="icon-play fa-play"></i>
<div class="metro-animation">
  <div id="alg-4" class="metro-graph"></div>
</div>
#+END_EXPORT

Cool. It worked for a single line, but the algorithm is still not taking into account connections and multiple lines.

** Multiple lines
Just out of curiosity, let's try to run the current state of the algorithm in a configuration with multiple lines

#+BEGIN_EXPORT html
<i id="alg-5-button" class="icon-play fa-play"></i>
<div class="metro-animation">
  <div id="alg-5" class="metro-graph"></div>
</div>
#+END_EXPORT

# When we introduce another line, a good point is that, accidentally, we're handling the case of unvisited predecessors.
There is still a problem that the stations of other lines are not even considered when a line finishes to visit all stations.
To solve this, we need to introduce a new data structure which holds the stations that are still waiting to be visited,
the so-called pending nodes.

#+BEGIN_SRC clojure :exports result
(defn traverse-graph-with-pending-stations
  "When picking a station from multiple successors,
   add the remaining stations in the pending-nodes list"
  [state]
  (let [{:keys [graph current-node current-line pending-nodes end]} state
        predecessor (find-predecessor graph current-node)
        successors (find-successors graph current-node)]
    (cond
      (not (nil? predecessor))
      (traverse-graph-with-pending-stations (assoc state :current-node predecessor))

      (and (visited? graph current-node) (seq successors))
      (traverse-graph-with-pending-stations (assoc state
                                    :current-node (first successors)
                                    :pending-nodes (concat pending-nodes (rest successors))))

      (and (visited? graph current-node) (empty? successors))
      (traverse-graph-with-pending-stations (assoc state
                                    :current-node (first pending-nodes)
                                    :pending-nodes (rest pending-nodes)))

      :else
      (assoc state
             :pending-nodes (remove #{current-node} pending-nodes)
             :current-line (metro.graph/lines graph current-node)
             :graph (loom.attr/add-attr graph current-node :visited true)))))

=> (def config [{:name "Green" :stations ["A", "B", "C"]},
             {:name "Red" :stations ["D", "B", "E"]}])
=> (def g (metro.blog/build-graph config))

=> (def state1 (traverse-graph-with-pending-stations {:graph g :current-node "B"}))
;; {:current-node "A", :pending-nodes (), :current-line ["Green"]}
=> (def state2 (traverse-graph-with-pending-stations state1))
;; {:current-node "D", :pending-nodes (), :current-line ["Red"]}
=> (def state3 (traverse-graph-with-pending-stations state2))
;; {:current-node "B", :pending-nodes (), :current-line ["Red" "Green"]}
=> (def state4 (traverse-graph-with-pending-stations state2))
;; {:current-node "E", :pending-nodes ("C"), :current-line ["Red"]}
=> (def state5 (traverse-graph-with-pending-stations state2))
;; {:current-node "E", :pending-nodes (), :current-line ["Green"]}
#+END_SRC

With this result, notice how after green line finishes, we also take the other stations of the red line into account.

#+BEGIN_EXPORT html
<i id="alg-6-button" class="icon-play fa-play"></i>
<div class="metro-animation">
  <div id="alg-6" class="metro-graph"></div>
</div>
#+END_EXPORT

** Everything comes to an end
All the recursive algorithms need a stop case, otherwise, they run indefinitely.

For this case, when the line doesn't have more stations to visit and no more pending stations,
we add a new key ~end~ to the returned state. In the next iteration, ~nil~ is returned if this key is present.

#+BEGIN_SRC clojure :exports result
(defn traverse-graph
  "In the final station, pass a key called end. If this key is present, nil is returned"
  [state]
  (let [{:keys [graph current-node current-line pending-nodes end]} state
        predecessor (find-predecessor graph current-node)
        successors (find-successors graph current-node)]
    (cond
      end nil

      (not (nil? predecessor))
      (traverse-graph (assoc state :current-node predecessor))

      (and (visited? graph current-node) (seq successors))
      (traverse-graph (assoc state
                              :current-node (first successors)
                              :pending-nodes (concat pending-nodes (rest successors))))

      (and (visited? graph current-node) (empty? successors))
      (traverse-graph (assoc state
                              :current-node (first pending-nodes)
                              :pending-nodes (rest pending-nodes)))
      (and (empty? successors) (empty? pending-nodes))
      (assoc state
             :current-line (metro.graph/lines graph current-node)
             :graph (loom.attr/add-attr graph current-node :visited true)
             :end true)

      :else
      (assoc state
             :pending-nodes (remove #{current-node} pending-nodes)
             :current-line (metro.graph/lines graph current-node)
             :graph (loom.attr/add-attr graph current-node :visited true)))))

(def config [{:name "Red" :stations ["A" "B" "C"]}])
(def graph (build-graph config))
(def state1 (traverse-subway-graph {:graph graph})
;; {:current-node "A" :current-line '("Red") :pending-nodes ()}
(def state2 (traverse-subway-graph state1))
;; {:current-node "B" :current-line '("Red") :pending-nodes ()}
(def state3 (traverse-subway-graph state2))
;; {:current-node "C" :current-line '("Red") :pending-nodes ()}
(def state4 (traverse-subway-graph state3))
;; nil
#+END_SRC

** Helper function to hide some details
One disadvantage of this approach is that the initial state should contain boilerplate data such as ~pending-nodes~, ~current-node~, etc.
To alleviate this problem for now, we can encapsulate this logic into its own bootstrap function.

#+BEGIN_SRC clojure :exports result
(defn initial-state
  [graph]
  (let [station (first (loom.graph/nodes graph))]
    {:graph graph
     :pending-nodes ()
     :current-node station
     :current-line (lines graph station)}))

(def config [{:name "Red" :stations ["A" "B" "C"]}])
(def graph (build-graph config))
(def initial-state (initial-state config))
(def state1 (traverse-graph initial-state))
#+END_SRC

* Generate git commands
One last piece of the puzzle is to create *one or more git commands* for each new iteration of the traversal.

For each iterated station, essentially, the algorithm needs to perform two tasks in this order:
1. Switch (move the ~HEAD~) to a branch/line or create a branch/line and then move the ~HEAD~ to it.
2. Generate a (simple/merge) commit with the station name and, when dealing with multiple branches, move the other branchs to this new commit.

In the switching branch phase:
- When ~HEAD~ is ponting to some of the input branches, don't issue any command.
- When ~HEAD~ is not pointing to some of input branches, but some line already exists, issue a ~checkout~ command.
- When ~HEAD~ is not pointing to some of input branches, and all of the branches don't exist, create a ~checkout --orphan~ command.

In the command generation phase:
- If it's a single line, create a simple ~commit~.
- If, at least two lines (branches) are coming from different stations (commits), create a ~merge commit~ and move the remaining branches (~branch -f~) to this new commit.
- When all the lines (branches) are coming from the same station (commit), generate a simple ~commit~ and then move the other branches (~branch -f~) to the new commit.

** Single line/branch
Again, starting with the simplest case, which is a single line which yields only ~checkout~ and ~commit~ commands.

Just remembering that this function only receives commit names and branches
and it's totally decoupled from the traversal algorithm.

#+BEGIN_SRC clojure :exports result
(defn git-checkout
  [branch current-branches]
  (if (contains? (set current-branches) branch)
    (str "git checkout \"" branch "\"")
    (str "git checkout --orphan \"" branch "\"")))

(defn git-commit
  [commit-name]
  (str "git commit --allow-empty -m \"" commit-name "\""))

(defn create-git-commands-single
  "Returns an array of commands from a single line/branch"
  ([commit-name branch]
   (create-git-commands-single {} commit-name branch))

  ([state commit-name branch]
   (let [current-branch (:current-branch state)
         commands (atom [])]

     (if (nil? current-branch)
       (swap! commands conj (git-checkout commit-name branch)))

     (swap! commands conj (git-commit commit-name))

     (assoc state
            :commands (flatten (deref commands))
            :current-branch branch))))

=> (def state1 (create-git-commands-single "A" '("Blue")))
=> (:commands state1)
;; ("git checkout --orphan \"A\"" "git commit --allow-empty -m \"A\"")
=> (def state2 (create-git-commands-single state1 "B" '("Blue")))
=> (:commands state2)
;; ("git commit --allow-empty -m \"B\"")
=> (def state3 (create-git-commands-single state2 "C" '("Blue")))
=> (:commands state3)
;; ("git commit --allow-empty -m \"C\"")
#+END_SRC

We're changing the variable ~commands~ in two different places of the same function.
The
@@html:<a href="https://clojure.org/reference/atoms" target="_blank">atom</a>@@
construct was used to update a value in two different places of the same function,
but it doesn't make our function less immutable or pure *to the outside world*.
This
@@html:<a href="https://clojure.org/reference/transients" target="_blank">quote</a>@@
from Rich Hickey explains why this is not a problem.

#+BEGIN_QUOTE
#+BEGIN_EXPORT html
<p>
If a tree falls in the woods, does it make a sound? <br/>
If a pure function mutates some local data in order to produce an immutable return value, is that ok?
</p>
#+END_EXPORT
#+END_QUOTE

#+BEGIN_EXPORT html
<i id="alg-7-button" class="icon-play fa-play"></i>
<div class="metro-animation-git">
  <div id="alg-7" class="metro-graph"></div>
  <div id="alg-7-git" class="metro-git-container"></div>
</div>
#+END_EXPORT

** Emulating a git repository
When dealing with multiple branches,
we need to keep track of where ~HEAD~ is pointing and the last commit that the branches are pointing to.

Instead of using a real life git repository to have this logic of handling with existing branches and commits,
we can represent it as a plain old Clojure(script) map.
Each new iteration can update this map with the current state of branches and commits.
Basically, our "fake" repo can be represented as:

#+BEGIN_SRC clojure :exports result
(def repo {"Red" "B", "Blue" "D"})
(def head :Red)
#+END_SRC

A quick remark is that our ~HEAD~ points to a branch, instead of a ~commit~ like the original git repository.
It's done like this because it's with the branch we need to check if an additional ~checkout~ command is necessary.
Besides we store only the last commit of the branch to decide if we need to generate a merge or a simple commit.

# A quick remark is that ~HEAD~ points to a commit in the original git repository,
# but our ~HEAD~ points to a branch
# because only the branch is necessary to check if we need to issue a ~checkout~ command or not.

** Picking the HEAD
At the beginning of the algorithm, we need to decide if it's possible to stick with the current ~HEAD~.
If the same ~HEAD~ is picked, we can save unnecessaries ~checkout~ commands.

#+BEGIN_SRC clojure :exports result
(defn pick-head
  [current-head repo station-branches]
  (if (and
       (contains? (set station-branches) current-head)
       (contains? (set (keys repo)) current-head))
    current-head
    (first station-branches)))

;; Initial iteration
(def head1 (pick-head nil {} '("Blue")))
=> "Blue"
;; The iterated station has a Red and Blue branch,
;; but only the Blue branch exists in our repo
(def head2 (pick-head head1 {"Blue" "A"} '("Red" "Blue")))
=> "Blue"
;; We're gonna need to switch HEAD
;; because the Blue line is not in the iterated station
(def head3 (pick-head head2 {"Blue" "B" "Red" "B"} '("Red")))
=> "Red"
#+END_SRC

#+BEGIN_EXPORT html
<i id="alg-8-button" class="icon-play fa-play"></i>
<div class="metro-animation-git">
  <div id="alg-8" class="metro-graph"></div>
  <div id="alg-8-git" class="metro-git-container"></div>
</div>
#+END_EXPORT

** Merge branches
When the iterated station has multiple branches and they're coming from different commits, we generate a merge commit.

#+BEGIN_SRC clojure :exports result
(defn find-merge-branches
  [head repo branches]
  (let [head-station (get repo head)]
    (filter
     (fn [branch]
       (let [branch-station (get repo branch)]
         (and
          (not (nil? branch-station))
          (not= branch-station head-station)
          (not= branch head))))
     branches)))

(find-merge-branches nil {} '("Blue")
=> ()

(find-merge-branches "Blue" {"Blue" "A"} '("Red"))
=> ()

(find-merge-branches "Red" {"Blue" "A" "Red" "C"} '("Red" "Blue"))
=> ("Blue")
#+END_SRC


#+BEGIN_EXPORT html
<i id="alg-9-button" class="icon-play fa-play"></i>
<div class="metro-animation-git">
  <div id="alg-9" class="metro-graph"></div>
  <div id="alg-9-git" class="metro-git-container"></div>
</div>
#+END_EXPORT

** Companion branches
When multiple branches are coming from the same commit, we can't generate a merge commit
because these branches are not divergent and can't be...merged.
If you try to do this, git will raise the ~Already up to date~ message.

To identify these cases, we can check if the evaluated lines are simply not inside the merging branches set.

#+BEGIN_SRC clojure :exports result
(defn find-companion-branches
  [head merging-branches branches]
  (->>
   (set/difference (set branches) (set merging-branches))
   (remove #{head})))

(find-companion-branches "Red" '("B") '())
=> ()
(find-companion-branches "Red" '() '("Red" "Blue"))
=> ("Blue")
#+END_SRC

#+BEGIN_EXPORT html
<i id="alg-10-button" class="icon-play fa-play"></i>
<div class="metro-animation-git">
  <div id="alg-10" class="metro-graph"></div>
  <div id="alg-10-git" class="metro-git-container"></div>
</div>
#+END_EXPORT

** Fitting the pieces together
Now that all of the pieces were introduced, we can fill the gaps and assemble the rest of the implementation.

#+BEGIN_SRC clojure :exports result
(defn git-force-branch
  [branches]
  (map (fn [branch] (str "git branch -f \"" branch "\" HEAD")) branches))

(defn git-merge
  [commit-name branches]
  (str "git merge --strategy=ours --allow-unrelated-histories --no-ff --commit -m \""
       commit-name
       "\" "
       (str/join " " branches)))

(defn update-repo
  [repo branches commit-name]
  (into repo (map (fn [branch] {branch commit-name}) branches)))

(defn create-git-commands
  ([commit-name branches]
   (create-git-commands2 {} commit-name branches))

  ([state commit-name branches]
   (let [repo (or (:repo state) {})
         head (:head state)
         commands (atom [])
         new-head (pick-head head repo branches)]

     (if-not (= head new-head)
       (swap! commands conj (git-checkout new-head (keys repo))))

     (let [merging-branches (find-divergent-branches new-head repo branches)
           remaining-branches (find-remaining-branches new-head merging-branches branches)]
       (if (> (count merging-branches) 0)
         (swap! commands conj (git-merge commit-name merging-branches))
         (swap! commands conj (git-commit commit-name)))

       (let [not-head-branches (concat merging-branches remaining-branches)]
         (swap! commands conj (git-force-branch not-head-branches))))

     (assoc state :commands (flatten (deref commands))
            :head new-head
            :repo (update-repo repo branches commit-name)))))

(def config
  [{:name "Green" :stations ["A", "D", "E"]},
   {:name "Red" :stations ["B", "D", "F", "G"]},
   {:name "Blue" :stations ["C", "D", "F", "H"]}])
(def g (build-graph config))

(def alg-state1 (traverse-graph (initial-state g)))
(def git-state1 (create-git-commands (:current-node alg-state1) (:current-line alg-state1)))

(def alg-state2 (traverse-graph alg-state1))
(def git-state2 (create-git-commands git-state1 (:current-node alg-state2) (:current-line alg-state2)))

(def alg-state3 (traverse-graph alg-state2))
(def git-state3 (create-git-commands git-state2 (:current-node alg-state3) (:current-line alg-state3)))

(def alg-state4 (traverse-graph alg-state3))
(def git-state4 (create-git-commands git-state3 (:current-node alg-state4) (:current-line alg-state4)))
(:commands git-state4)
=> ("git merge --strategy=ours --allow-unrelated-histories --no-ff --commit -m \"D\" Red Blue"
    "git branch -f \"Red\" HEAD"
    "git branch -f \"Blue\" HEAD")
(:head git-state4)
=> "Green"
(:repo git-state4)
=> {"Blue" "D", "Red" "D", "Green" "D"}
#+END_SRC

#+BEGIN_EXPORT html
<i id="alg-11-button" class="icon-play fa-play"></i>
<div class="metro-animation-git">
  <div id="alg-11" class="metro-graph"></div>
  <div id="alg-11-git" class="metro-git-container"></div>
</div>
#+END_EXPORT

* seq abstraction to the rescue
One part we call all agree o is that the current API to generate these commands really sucks.
The user needs to call a lot of boilerplate functions to get the job done.
Also, a lot of internal information, like the state of the traversal algorithm and the git repository, is being exposed in those calls.
The clients of this program are only interested in one thing: generate the git commands from a metro configuration.

Fortunately, Clojure got our back.

It's possible to produce our own custom collection-like by creating a new type using the ~deftype~ function that's gonna implement the ~ISeq~ interface.
In exchange, Clojure only asks us to implement 4 functions:
- *first*: The first element of the iteration when traversing the graph. If there are no more elements, it returns ~nil~.
- *more* for Clojure or *rest* for Clojurescript: Returns the rest of the collection without the first element. Always returns a collection.
- *next*: Returns the next element of the iteration. Same as rest, but returns ~nil~ when there are no more elements.
- *seq*: Transforms this type in a sequence. In this case, the instance of our type is already a sequence, so we just return itself.

#+BEGIN_SRC clojure exports result
(declare seq-first seq-rest seq-next)

(deftype MetroGraph [algorithm-state git-state]
  clojure.lang.ISeq
  (first [self] (seq-first algorithm-state git-state))

  (more [self] (seq-rest self))

  (next [self] (seq-next algorithm-state git-state))

  (seq [self] self))

(defn seq-first
  [algorithm-state git-state]
  {:station (:current-node algorithm-state)
   :line (:current-line algorithm-state)
   :commands (:commands git-state)
   :state algorithm-state})

(defn seq-rest
  [self]
  (or (next self) '()))

(defn seq-next
  [algorithm-state git-state]
  (let [new-state (traverse-graph algorithm-state)]
    (when-not (nil? new-state)
      (let [new-git-state (create-git-commands git-state
                                                         (:current-node new-state)
                                                         (:current-line new-state))]
        (MetroGraph. new-state new-git-state)))))

(defn build-seq
  [initial-state]
  (MetroGraph. initial-state
               (metro.git/create-git-commands
                (:current-node initial-state)
                (:current-line initial-state))))

(defn metro-git-seq
  [config]
  (build-seq
   (-> config
       (build-graph)
       (initial-state)
       (traverse-graph))))

(def config [{:name "Red", :stations ["A", "C"]},
                {:name "Green", :stations ["B", "C"]}])
(:commands (first (metro-git-seq config)))

(:line (last (metro-git-seq config)))

(:station (second (metro-git-seq config)))
#+END_SRC

We now have a straightforward and encapsulated way of creating and traversing and generating the git commands.
With this new type, we can reuse some ready-made functions that we all learned to love from Clojure.

#+BEGIN_SRC clojure exports result
;; load-from-file simply transforms the text file into a EDN
(def nyc-config (load-from-file "nyc.txt"))
(def nyc-seq (metro-git-seq nyc-config))

;; lines of  New York City
(sort (set (flatten (map :line nyc-seq))))
=> ("1" "2" "3" "4" "5" "6" "7" "A" "B" "C" "D"
    "E" "F" "G" "J" "L" "M" "N" "Q" "R" "W" "Z")

;; Stations that have more than 6 connections
(map :station (filter #(> (count (:line %)) 6) nyc-seq))
=> ("West 4 Street - Washington Square / 6 Avenue"
    "Atlantic Avenue / Barclays Center")

;; Number of merge commits
(count (filter #(str/starts-with? % "git merge") (mapcat :commands nyc-seq)))
=> 62
#+END_SRC

But, the most important part is creating a new file with the git commands.

_Test this please_
#+BEGIN_SRC clojure exports result
;; Write the git commands to a file
(spit "nyc.sh" (str/join "\n" (mapcat :commands nyc-seq)))
(sh "mkdir nyc_repo")
(sh "git" "init" :dir "nyc_repo")
(sh "../nyc.sh" :dir "nyc_repo")
(println(sh git log --oneline
# 670b346 (HEAD -> M) Forest Avenue / 67 Avenue
# eb8a8e4 Hewes Street / Broadway
# 6a97c04 Lorimer Street / Broadway
# cfddc65 Flushing Avenue / Broadway
# c503053 Kosciuszko Street / Broadway
# 1cb5df7 Halsey Street / Broadway
#+END_SRC

* That's it, folks
Phew. We reached the end of the journey of mapping git commands from a metro system.
I hope it was a pleasant experience and you learned something new.

I wanna thank the creators of
@@html:<a href="https://github.com/vbarbaresi/MetroGit" target="_blank">MetroGit</a>@@
(Paris) where I got the original idea
and
@@html:<a href="https://github.com/bburky/git-dc-metro" target="_blank">git-dc-metro</a>@@
(Washington) where I took the inspiration of the format of the commands =P

If you're curious, the code for the project
@@html:<a href="https://github.com/gjhenrique/metro-clojure" target="_blank">metro-clojure</a>@@
is in github.
If you want to, you can open an issue requesting a new city.

Another great thing about Clojure(script) is that the animations demonstrating the traversal and creation
uses the same code but transpiled to JS.

Also, sorry for the CPU usage of the animations. ;)
