#+BEGIN_EXPORT html
---
layout: post
title: Converting metro connections to git graph (Improve me)
comments: false
custom_js:
  - http://localhost:8080/prod/main.js
  - ./res/metro/custom.js
categories:
  - programming
tags:
  - clojure
  - subway
styles:
  - "https://fonts.googleapis.com/css?family=Source+Code+Pro"
---
#+END_EXPORT

A few years back, I was trying to learn Clojure, had read some books and was looking for an interesting project to apply the knowledge.
Then I remembered the project [[https://github.com/vbarbaresi/MetroGit%0A][MetroGit]] which consists of building a Git graph from the metro system of Paris.
In my opinion, this project is so creative and simple that the original idea could see some improvement.

So, the idea for this project is to build the git graph through shell commands with some sets of lines, stations and connections.
The lines will be represented as branches, stations as stations and connections as merge commits.

To make this process more engaging, the psot was splitted into some core sections:
1. Building the graph from the input data
2. Traversing in a way that's easier
3. Generating the git commands

* Illustration of the idea
In a nutshell, we need to transform a bunch of unknown stations and connection to a git graph.

As an example, this piece of [[https://pt.saopaulomap360.com/mapa-metro-sao-paulo][São Paulo]] metro system:
[[./res/metro/metro-sp.png]]

Will generate these shell commands:

#+BEGIN_SRC shell-script :exports result
# República
git checkout --orphan "Red"
git commit --allow-empty -m "República"
git branch -f "Yellow" HEAD

# Anhangabaú
git commit --allow-empty -m "Anhangabaú"

# Luz
git checkout "Yellow"
git commit --allow-empty -m "Luz"
git branch -f "Blue" HEAD

# Sao Bento
git checkout "Blue"
git commit --allow-empty -m "São Bento"

# Sé
git merge --strategy=ours --allow-unrelated-histories \
--no-ff --commit -m "Sé" Red

# Liberdade
git commit --allow-empty -m "Liberdade"

# Pedro II
git checkout "Red"
git commit --allow-empty -m "Pedro II"
#+END_SRC

Which produces the following git graph (~git log --graph --all --pretty=oneline~ command):

[[./res/metro/git-result.png]]

This idea brings some complications regarding the constraints of this algorithm.

1. A git graph is a [[http://eagain.net/articles/git-for-computer-scientists/][Directed *Acyclic* Graph]], which means we can't have cycles in the connections.
2. If there is a cycle, we need to remove the *minimum* number of stations.
3. The traversal needs to take into account the correct visitation order to build the correct git commands

_Improve me_
The next steps will focus on the each step
break down the components

* Building the graph
The first step is to build a directed graph without cycles, which means we'll need to identify cycles and potentially remove some connections.

** Input data
Defining the input data is the least of our worries. It could be represented as ~json~ or ~xml~.
But, since we're using Clojure, let's represent this data in the [[https://clojure.github.io/clojure/clojure.edn-api.html][Extensible Data Notation]].
This way, it's not necessary to write extra code to transform data types.

Also, we're working with fictitious lines called Red, Green and Blue and stations called "A", "B" and "C".

#+BEGIN_SRC clojure :exports result
=> (def config [{:name "Red", :stations ["A", "C"]},
                {:name "Green", :stations ["B", "C"]}])

=> (:name (first config))
"Red"
=> (:stations (first config))
["A" "C"]
#+END_SRC

** Using loom
For Clojure(script), there is an awesome library called [[https://github.com/aysylu/loom][loom]], which provides an exceptional API to work with graphs.
It's gonna be the foundation of the project

#+BEGIN_SRC clojure :exports result
;; Create the graph with the connections
=> (def g1 (loom.graph/digraph ["A" "B"] ["B" "C"]))

;; Add the line name as an attribute of the node
=> (def g2 (-> g1
              (loom.attr/add-attr "A" :lines ["Blue"])
              (loom.attr/add-attr "B" :lines ["Blue"])
              (loom.attr/add-attr "C" :lines ["Blue" "Red"])))

=> (loom.graph/edges g2)
(["B" "C"] ["A" "B"])

=> (loom.graph/successors g2 "B")
#{"C"}

=> (loom.graph/predecessors g2 "B")
#{"A"}

=> (loom.attr/attr g2 "C" :lines)
["Blue" "Red"]

=> (loom.alg/dag? g2)
true
#+END_SRC

** Without cycles
In the planning phase of the new stations,
the subway engineers don't care if they'll introduce a cycle in their infrastructure (why would they, right?!)

But, to start, let's not think about the cycles yet.

#+BEGIN_SRC clojure :exports result
(defn- add-line-information
  [graph stations line-name]
  "Auxiliary function to add the line name to stations"
  (reduce
   (fn [g station]
     (->>
      ;; To not override other lines
      (conj (or (loom.attr/attr g station :lines) []) line-name)
      ;; Add the attribute to the graph
      (loom.attr/add-attr g station :lines)))
   graph
   stations))

(defn build-graph
  [config]
  "Build a graph without worrying about cycles"
  (reduce
   (fn [graph line]
     ;; partition transforms [A B C] into (("C" "B") ("B" "A"))
     (let [connections (partition 2 1 (:stations line))
           ;; add these edges into the graph
           new-graph (apply loom.graph/digraph graph connections)]
       ;; add the line as attributes in the nodes, it works even with connections

       (add-attribute new-graph (:stations line) (:name line))))
   ;; Start with an empty digraph
   (loom.graph/digraph)
   config))
#+END_SRC

This code produces the following result:
#+BEGIN_SRC clojure :exports result
=> (def config [{:name "Red", :stations ["A", "C"]},
                {:name "Blue", :stations ["B", "C"]}])
=> (def g (build-graph config))

=> (loom.graph/edges g)
   (["B" "C"] ["A" "C"])
=> (loom.graph/nodes g)
    #{"C" "B" "A"}
=> (loom.attr/attr g "A" :lines)
   ["Red"]
=> (loom.attr/attr g "C" :lines)
   ["Red" "Blue"]
#+END_SRC

And it yields the following graph:
#+BEGIN_EXPORT html
<div class="metro-animation">
  <div id="build-1" class="metro-graph"></div>
</div>
#+END_EXPORT

The violet station is represented as a connection between red and blue.

** Reversing connections
Before start removing some connections, a less damaging approach is possible.
There is an interesting heuristics that subway lines are bidirectional, which makes sense.
Imagine going to work with a subway but having to return back with a car.

Because of this, when introducing a cycle, we could try to reverse the connections of the culprit line.


#+BEGIN_SRC diff :exports result
- (let [connections (partition 2 1 (:stations line))
+ (let [connections (valid-connection graph line-config)
#+END_SRC

#+BEGIN_SRC clojure :exports result
(defn- reverse-stations
  [connections]
  (map
   (fn [info] [(second info) (first info)])
   (reverse connections)))

(defn- add-connections
  [graph connections]
  (let [new-graph (apply loom.graph/digraph graph connections)]
    (when (loom.alg/dag? new-graph) connections)))

(defn- valid-connection
  [graph line-config]
  (let [line-name (:name line-config)
        connections (partition 2 1 (:stations line-config))]
    (or (add-connections graph connections)
        (add-connections graph (reverse-stations connections)))))
#+END_SRC

Keep in mind that the call to ~loom.graph/dag?~ does a [[https://en.wikipedia.org/wiki/Topological_sorting][Topological sorting]], which takes ~O(E+V)~.
By the way, ~E~ (edges) are the stations and the ~V~ (vertex) are the connections between them.
Therefore, this algorithm run in ~O(L*(E+V))~ where L is the number of lines.

#+BEGIN_SRC clojure :exports result
=> (def config [{:name "Red" :stations ["B" "C" "D"]}
              {:name "Blue" :stations ["A" "D" "B"]}])

=> (def g (build-graph config))

=> (loom.graph/edges g)
(["C" "D"] ["B" "C"] ["B" "D"] ["D" "A"])

=> (loom.graph/predecessors g "D")
#{"C" "B"}
#+END_SRC

#+BEGIN_EXPORT html
<div class="metro-animation">
  <div id="build-2" class="metro-graph"></div>
</div>
#+END_EXPORT

Notice that the ~B~ station connects to the ~D~ station.
#+BEGIN_EXPORT html
<div class="metro-animation">
  <div id="build-3" class="metro-graph"></div>
</div>
#+END_EXPORT

** Removing connections/edges
If even after reversing the station lines, there are still cycles, the last resort is to remove the connections that introduced a cycle.

The used algorithm is simple and it's based on this [[https://stackoverflow.com/questions/20246417/how-to-detect-if-adding-an-edge-to-a-directed-graph-results-in-a-cycle][stackoverflow answer]].
The idea is to check if a new connection will introduce a cycle. If it does, then that connection is dropped.

#+BEGIN_SRC diff :exports result
(or (add-connections graph connections)
-  (add-connections graph (reverse-stations connections)))))
+  (add-connections graph (reverse-stations connections))
+  (connections-without-cycle graph (:stations line-config) line-name))))

#+END_SRC

#+BEGIN_SRC clojure :exports result
(defn- connections-without-cycle
  [graph stations line-name]
  (loop [g graph
         final-stations [(first stations)]
         iteration-stations (rest stations)]

    (if (empty? iteration-stations)
      (partition 2 1 final-stations)

      (let [new-graph
            (loom.graph/digraph g [(last final-stations)
                                   (first iteration-stations)])]
        (if (loom.alg/dag? new-graph)
          (recur new-graph
                 (conj final-stations (first iteration-stations))
                 (rest iteration-stations))

            (recur graph final-stations (rest iteration-stations)))))))

#+END_SRC

#+BEGIN_SRC clojure :exports result
(def config [{:name "Red" :stations ["A" "B" "C" "A"]}])
(def g (build-graph config))
=> (loom.graph/nodes g)
#{"C" "B" "A"}
=> (loom.graph/edges g)
(["B" "C"] ["A" "B"])
=>
=> (loom.alg/dag? g)
true
#+END_SRC

The algorithm is costly ~O(E*(V+E))~ and could be improved, but our nodes and vertex are usually small.
In the majority of cases, a station has only one connection _(WHAT?)_, also, most of the stations won't introduce cycles.

Albeit simple, this algorithm behaved well in the New York subway system. It removed only 4 of 496 connections.

#+BEGIN_EXPORT html
<div class="metro-animation">
  <div id="build-4" class="metro-graph"></div>
</div>
#+END_EXPORT

The ~D->A~ connection was removed.
#+BEGIN_EXPORT html
<div class="metro-animation">
  <div id="build-5" class="metro-graph"></div>
</div>
#+END_EXPORT

* Traversal
Now that the graph builder is built. We can worry about the traversal algorithm.

The traversal algorithm should make the git graph construction possible and has the following characteristics:
- All of the stations should be visited *only* once
- The station can only be marked as visited when it's the first station or all of their predecessors are already visited
- After the station is marked as visited, we should assess its successors (more than one in case of a connection)
- After the last station of the line is reached, we need to check other non visited stations
- When all of the stations are visited, then we reach the end of the traversal.

It seems complicated, but each condition with a new constraint is gonna be introduced individually, so it's not gonna be a big pill to swallow.

** In search of the correct API
The idea is to have a function that abstracts away all these logic requirements.

Each call of the function will return the current state of the algorithm.
In the next sections, we'll see that we can build from this to build a even more powerful abstraction.

In a nutshell, here is the higher level view of this API:
#+BEGIN_SRC  clojure :exports result
(def config [{:name "Red" :stations ["A" "C"]}
             {:name "Blue" :stations ["B" "C"]}])

;; Using function to build the loom dag from the input data
(def graph (build-graph config))

;; We can store graph related data as attributes of the vertex
(def state1 (traverse-subway-graph {:graph graph})
;; {:current-node "A" :current-line "Red" :graph graph-1}

(def state2 (traverse-subway-graph state1))
;; {:current-node "B" :current-line "Blue" :graph graph-2}

(def state3 (traverse-subway-graph state2))
;; {:current-node "C" :current-line ("Blue" "Red") :graph graph-3}

;; No more stations to process
(def state4 (traverse-subway-graph state3))
;; nil
#+END_SRC

The next sections will handle the implementation of the ~traverse-subway-graph~

** Stations with only one line
Let's start with the simplest case. A subway system with only one line.

#+BEGIN_EXPORT html
<div class="metro-animation">
  <div id="alg-1" class="metro-graph"></div>
</div>
#+END_EXPORT

#+BEGIN_SRC clojure :exports result
(defn- lines
  [graph node]
  (loom.attr/attr graph node :lines))

  (defn traverse-graph1
  [state]
  (let [{:keys [graph current-node current-line]} state]
      (assoc state
             :current-line (lines graph current-node)
             :graph (loom.attr/add-attr graph current-node :visited true))))
             
(defn traverse-graph-1
  [state]
  "Receiving a map as the values of each state.
   Does not worry with predecessors or successors"
  (let [{:keys [graph current-node current-line]} state]
      (assoc state
             :current-line (lines graph current-node)
             :graph (attr/add-attr graph current-node :visited true))))
#+END_SRC

#+BEGIN_SRC clojure :exports result
(def config [{:name "Green" :stations ["A" "B" "C"]}])
(def g (build--graph config))

=> (def state1 (traverse-subway-graph {:graph g :current-node "B"}))
{:graph loom_graph, :current-node "B", :current-line ["Green"]}
=> (def state1 (traverse-subway-graph {:graph g :current-node "B"}))
{:graph loom_graph, :current-node "B", :current-line ["Green"]}
#+END_SRC

#+BEGIN_EXPORT html
<i id="alg-2-button" class="icon-play fa-play"></i>
<div class="metro-animation">
  <div id="alg-2" class="metro-graph"></div>
</div>
#+END_EXPORT

Not so great. For now, it's just returning the same station every time, but the we already know how the algorithm should behave.
The next case we should focus is to find the predecessors which weren't visited yet.

#+BEGIN_SRC clojure :exports result
(defn visited?
  [graph station]
  (loom.attr/attr graph station :visited))

(defn find-predecessor
  [graph station]
  "Finds the non visited predecessors of station"
  (first (filter
          (fn [p] (not (visited? graph p)))
          (loom.graph/predecessors graph station))))

(defn traverse-subway-graph
  [state]
  (let [{:keys [graph current-node current-line]} state
        predecessor (metro.algorithm/find-predecessor graph current-node)]
    (cond
      (not (nil? predecessor))
      (traverse-subway-graph (assoc state :current-node predecessor))

      :else
      (assoc state
             :current-line (metro.graph/lines graph current-node)
             :graph (attr/add-attr graph current-node :visited true)))))

#+END_SRC

#+BEGIN_EXPORT html
<i id="alg-3-button" class="icon-play fa-play"></i>
<div class="metro-animation">
  <div id="alg-3" class="metro-graph"></div>
</div>
#+END_EXPORT

It's better that we're returning to the beginning, but we're still not progressing in _improve me_.
Now, it's time to add the condition that, if the current node is visited, it should visit its successors.

#+BEGIN_SRC clojure :exports result
(defn find-successors
  [graph node]
  (filter
   (fn [s] (not (visited? graph s)))
          (loom.graph/successors graph node)))

(defn traverse-subway-graph
  [state]
  (let [{:keys [graph current-node current-line]} state
        predecessor (metro.algorithm/find-predecessor graph current-node)
        successors (metro.algorithm/find-successors graph current-node)]
    (cond
      (not (nil? predecessor))
      (traverse-subway-graph (assoc state :current-node predecessor))

      (and (metro.algorithm/visited? graph current-node) (seq successors))
      (traverse-subway-graph (assoc state :current-node (first successors)))

      :else
      (assoc state
             :current-line (metro.graph/lines graph current-node)
             :graph (attr/add-attr graph current-node :visited true)))))
#+END_SRC

#+BEGIN_EXPORT html
<i id="alg-4-button" class="icon-play fa-play"></i>
<div class="metro-animation">
  <div id="alg-4" class="metro-graph"></div>
</div>
#+END_EXPORT

Cool. It worked for a single line for now, but we're not worried yet with connections.

** Multiple lines
Let's try to run the current state of the algorithm in a configuration with multiple lines

#+BEGIN_EXPORT html
<i id="alg-5-button" class="icon-play fa-play"></i>
<div class="metro-animation">
  <div id="alg-5" class="metro-graph"></div>
</div>
#+END_EXPORT

When we introduce another line, a good point is that, for free, we're handling the case of non visited predecessors.
But, there is a problem that the remaining stations are not even considered in the algorithm when the station is finished.

We need to introduce an auxiliary data structure which will hold the nodes that are still waiting to be visited (pending nodes).

#+BEGIN_SRC clojure :exports result
(defn traverse-subway-graph
  [state]
  (let [{:keys [graph current-node current-line pending-nodes end]} state
        predecessor (find-predecessor graph current-node)
        successors (find-successors graph current-node)]
    (cond
      (and (not (nil? predecessor)))
      (traverse-subway-graph (assoc state :current-node predecessor))

      (and (visited? graph current-node) (seq successors))
      (traverse-subway-graph (assoc state
                                    :current-node (first successors)
                                    :pending-nodes (concat pending-nodes (rest successors))))

      (and (visited? graph current-node) (empty? successors))
      (traverse-subway-graph (assoc state
                                    :current-node (first pending-nodes)
                                    :pending-nodes (rest pending-nodes)))

      :else
      (assoc state
             :pending-nodes (remove #{current-node} pending-nodes)
             :current-line (metro.graph/lines graph current-node)
             :graph (attr/add-attr graph current-node :visited true)))))
#+END_SRC

With this result, notice how after green line finishes, we take the rest of blue line into account.

#+BEGIN_EXPORT html
<i id="alg-6-button" class="icon-play fa-play"></i>
<div class="metro-animation">
  <div id="alg-6" class="metro-graph"></div>
</div>
#+END_EXPORT

** Putting an end to the algorithm
Let's try to run the current code to verify how it's behaving.
In practice, this would mean:

#+BEGIN_EXPORT clojure exports: result
(def config [{:name "Red" :stations ["A" "B" "C"]}])
(def graph (build-graph config))
(def state1 (traverse-subway-graph {:graph graph})
;; {:current-node "A" :current-line "Red" :graph graph-1}
(def state2 (traverse-subway-graph state1))
;; {:current-node "B" :current-line "Red" :graph graph-1}
(def state3 (traverse-subway-graph state2))
;; {:current-node "C" :current-line "Red" :graph graph-1}
(def state4 (traverse-subway-graph state3))
;; {:current-node "C" :current-line "Red" :graph graph-1}
;; Ooops. this is not correct
(def state5 (traverse-subway-graph state4))
;; {:current-node "C" :current-line "Red" :graph graph-1}
;; Is this ever going to finish?!
#+END_EXPORT

All the recursive algorithms have a thing in common, It needs a stop case, otherwise, it's gonna run indefinitely.
When the line doesn't have more stations to visit or no more pending stations, we know it's time to finish the algorithm:

#+BEGIN_EXPORT diff exports: result
(defn traverse-subway-graph
- (let [{:keys [graph current-node current-line pending-nodes]} state
+ (let [{:keys [graph current-node current-line pending-nodes end]} state
  predecessor (metro.algorithm/find-predecessor graph current-node)
  (cond
+   end nil

+   (and (empty? successors) (empty? pending-nodes))
+      (assoc state
+             :current-line (metro.graph/lines graph current-node)
+             :graph (attr/add-attr graph current-node :visited true)
+             :end true)
#+END_EXPORT

** Add initial state

We have the traversal function ready receiving
#+BEGIN_SRC clojure :exports result
(defun initial-state
  [graph]
  (let [node (first (graph/nodes graph))]
    {:pending-nodes () :current-node node :current-line (metro.graph/lines graph node)}))
#+END_SRC


#+BEGIN_SRC clojure :exports result
(def config [{:name "Red" :stations ["A" "B" "C"]}])
(def graph (build-graph config))
(def initial-state (build-graph config))

(def state1 (build-subway-graph initial-state))
(:current-node state1)
(:current-line node)

(def state1 (traverse-subway-graph state2)
(:current-node state2)
(:current-line node)

(def state3 (traverse-subway-graph {:graph graph})
(:current-node state2)
(:current-line node)

(def state4 (traverse-subway-graph {:graph graph})
;; nil
#+END_SRC

# Although we have a functional code,
# the API of the function seems weird because the "clients" of this function would have to know the concept of ~state~, ~pending-nodes~ and ~graph~.

Honestly, this API is terrible because the consumer of these functions have to know the internal details of the algorithm, like the state of the algorithm.
Also, we have several

But don't worry about this for now because we'll improve this interface in future sections.

* Git commands
The last piece of the puzzle is, for each new iterated station in the traversal, to create one or more git commands.

The requirements of this algorithm are:
1. When a line of a station has a branch and ~HEAD~ is pointing to that branch, simply create the ~commit~ with the station as the message.
By the way, ~HEAD~ always points to the current branch.
2. If the branch exists but ~HEAD~ is not pointing to it, do a ~checkout~ followed by a ~commit~
3. When the line doesn't have a branch yet, a new branch is created with ~checkout --orphan~ and a ~commit~. 
~checkout --orphan~ will create and checkout to a new branch without having any predecessors.
1. If you visit a station with more than one station, first point the ~HEAD~ to an existing branch.
If there is at least two branches, do a ~merge~ with the name of the station name. 
After that, move the other branches to point to this new merge commit.
# The last cool part could be

The initial idea was to use a git library to support the git operations.
Initially, I was using [[http://www.eclipse.org/jgit/][~jgit~]] and it was working fine, but the Clojure binding didn't support ~checkout --orphan~ by that time.
Because of this, I decided to use native data structures to support the ~branches~, ~commits~ and ~HEAD~.
In the end, It was even better to follow this approach, because without an external library, 
it's possible to run the algorithm in the browser with Clojurescript.

** Defining git operations
Before starting defining the algorithm, the helpers for the operations need to be built

#+BEGIN_SRC clojure :exports result
(defn git-checkout
  [branch current-branches]
  ;; current-branches have all the already created branches
  (if (contains? (set current-branches) branch)
    (str "git checkout \"" branch "\"")
    (str "git checkout --orphan \"" branch "\"")))

(defn git-commit
  [commit-name]
  (str "git commit --allow-empty -m \"" commit-name "\""))

(defn git-force-branch
  [branches]
  (map (fn [branch] (str "git branch -f \"" branch "\" HEAD")) branches))

(defn git-merge
  [commit-name branches]
  (str "git merge --strategy=ours --allow-unrelated-histories --no-ff --commit -m \""
       commit-name
       "\" "
       (str/join " " branches)))
       
=> (git-checkout "Blue" '("Blue" "Red" "Green"))
"git checkout \"Blue\""
=> (git-checkout "Blue" '("Red" "Green"))
"git checkout --orphan \"Blue\""
=> (git-commit "A")
"git commit --allow-empty -m \"A\""
=> (git-force-branch '("Blue" "Red"))
"git branch -f \"Blue\" HEAD" "git branch -f \"Red\" HEAD"
=> (git-merge "A" '("Blue" "Red"))
"git merge --strategy=ours --allow-unrelated-histories --no-ff --commit -m \"A\" Blue Red"
#+END_SRC

** Single commit
Again starting with the simplest case, which is a single station which yields only ~checkout~ and ~commit~ commands. 

#+BEGIN_SRC clojure :exports result
(defn create-git-commands
  ([commit-name branches]
   (create-git-commands {} commit-name branches))

  ([state commit-name branches]
    
  ))
#+END_SRC

We're changing the variable ~commands~ in two different places of the same function.
The [[https://clojure.org/reference/atoms][atom]] construct was introduced to update a shared value in two different places of the same function,
but it doesn't make our function less immutable or pure.
This [[https://clojure.org/reference/transients][quote]] from Rich Hickey explains why this is not a problem.

#+BEGIN_QUOTE
#+BEGIN_EXPORT html
<p>
If a tree falls in the woods, does it make a sound? <br/>
If a pure function mutates some local data in order to produce an immutable return value, is that ok?
</p>
#+END_EXPORT
#+END_QUOTE

#+BEGIN_EXPORT html
<i id="alg-7-button" class="icon-play fa-play"></i>
<div class="metro-animation">
  <div id="alg-7" class="metro-graph"></div>
  <div id="alg-7-git" class="metro-git-container"></div>
</div>
#+END_EXPORT

** Merge stations
When introducing another line/branch, we need to keep track of the

With more than one line, we need to keep track of the commits of each branch and also of the current ~HEAD~

_Introducing_ each new 

#+BEGIN_EXPORT html
<i id="alg-8-button" class="icon-play fa-play"></i>
<div class="metro-animation">
  <div id="alg-8" class="metro-graph"></div>
  <div id="alg-8-git" class="metro-git-container"></div>
</div>
#+END_EXPORT


** Follow up cases

* Sequential order to the mess
The current interface to generate the git commands sucks and it's time to fix that.

Clojure allows us to override the ~Seq~ type 

_explains what deftype_ is
_it's possible to override it some key functions_
_foundation to respond to a lot of_
_iterator Java and Enumerable ruby_

encapsulate
The idea is to encapsulate this logic into a facade function, exposing only the lines as single argument.

# polymorphism  nope, not related to polymorphism is not restricted to object oriented languages.
# in clojure a functional language it is achieved with protocols
# show how map, count, etc. are all used

#+BEGIN_SRC clojure exports result
code of deftype
#+END_SRC

#+BEGIN_SRC clojure exports result
some functions being implemented
#+END_SRC

# encapsulate the sequence

# metro-seq is awesome

* That's it, folks
Big thanks to washington project
check the project in github

the same code that is built to create the git commands is used to create these animations. it's amazing

the animations are written in clojurescript. the same algorithm that generated
check this link out and see for yourself.

# It's a combination of git, graph and clojure which means I found the perfect way to finally learn Clojure.

# sorry about the cpu usage of these animations, i didn't have the time to optimize

# to see if the algorithm really works, i tried to test with the bigger subway system of the world
# a lot of cycles were introduced, so we always had to check this
# also I built a parser of the page and the page introduced a lot of inconsistencies

thanks to washington since I copied some of the git commands from there

nyc subway is the big boss, since it's the larger
currently, there are only _sao paulo_ and _new york city_ implemented,
open _an issue_ if you would like to include your city in the list
anyway, thanks for reading this and sorry about the cpu usage of these animations.
