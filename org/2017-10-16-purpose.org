#+BEGIN_EXPORT html 
---
layout: post
title: Giving (emacs-)purpose to i3wm (or any other tiling window manager)
comments: false
categories:
  - programming
tags:
  - emacs
  - i3wm
  - window-purpose
---
#+END_EXPORT
#+OPTIONS: ^:nil

One fine day, imagine you're studying a ruby file in Emacs. 
Suddenly, you wanna open a REPL, run some tests or make some magit operations.
The problem is that all those buffers tend to compete with each other to a space in your window;
they keep overwriting each other.
This is a truly problem that a lot of Emacs users face: you struggle with the organization of the window layout.

Whit this post, I hope to show how the awesome tool [[https://github.com/bmag/emacs-purpose][purpose]] can help you to overcome this difficulty. 
The approach is to have multiple responsibilities (git, code, shell, tests, notes) each one with their own GUI window.
Purpose will not let that those windows overstepping each other and,
with the addition of a tiling window manager, you won't have the overhead of switching among them.

* how purpose can help?
Managing the window layout with purpose is easy but may take a little time to be tamed.
It provides us with two ways to deal with it:

- you designate a window to only accept buffers with *a certain major mode*; any other major mode will be opened on another window
- you register a *single* buffer to a window *regardless* of the mode and that buffer won't *ever* leave that window. 

I'll try to make these examples clearer with a few animations. 
Let's use the example about trying to manage regular ruby code and a [[https://github.com/pry/pry][pry]] REPL session.

The default behavior is showed first to better represent the problem that purpose solves.

[[./res/purpose/drawing-test.gif]]

#+BEGIN_SRC
gif with pry overriding the ruby file 
#+END_SRC

Notice how Emacs doesn't really care about the meaning of a buffer and will overwrite it without any consideration.
To give some context to those buffers, we have to declare the desired behavior in the configuration:

#+BEGIN_SRC emacs-lisp :exports result
;; ruby-mode buffers will have the ruby purpose
(add-to-list 'purpose-user-mode-purposes '(ruby-mode . ruby))
;; terminal buffers will have the terminal purpose
(add-to-list 'purpose-user-name-purposes '(comint-mode . terminal))
;; Populate purpose data structure
(purpose-compile-user-configuration)
#+END_SRC

# to enable it, use this
# purpose-user-mode-purposes
Surprisingly, with only these customizations, we can see purpose changing the behavior of window management.
When opening a new buffer, purpose will try to reuse a window if they share the same purpose.

#+BEGIN_SRC 
1. two ruby files
2. open ruby sell
3. tries to open a python file in cursor with shell, it opens in other buffer
4. go to the other 

first gif is python purpose and python shell purpose
focused on ruby and opening another magit buffer, it will open the magit buffer automatically
#+END_SRC

Now, imagine that, during your coding session, you want to only open the ruby code in the *left* window no matter what.
Now, you have to be explicit and assign the window to the terminal purpose.

#+BEGIN_SRC 
1. two python files
2. assign purpose to current window
3. open shell with the cursor the "purposed" window
4. it'll open in the other buffer
#+END_SRC

There's also the restrictive option to assign only the buffer to the window.
The first buffer will be *always* in the left window.
# In the last example you make it explicit that the left window would only have python buffers related with code, 
# but there's a possibility to assign a window to a buffer, not to a purpose.

#+BEGIN_SRC 
1. open a.rb
2. dedicate the buffer
3. open c.py
4. open it in the side window
#+END_SRC

These animations were the foundation of what purpose can offer you.
But, since the idea is to use a tiling window manager and multiple GUI windows, 
we want to have multiple frames each one with their own purpose. 

# We want that everything with python shell files to be opened in the first frame.

#+BEGIN_SRC 
1. first frame with a.py and b.py, second frame with the shell
2. assign to the terminal
3. try to run terminal dont open in another frame
4. it'll open in the python frame frame
#+END_SRC

Oh oh. That's not what we were expecting. 
That went wrong because we have to add the corresponding regex in the [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Display-Action-Functions.html][display-buffer-alist]].
If we don't do that, purpose doesn't consider opening the buffer in another frame.

#+BEGIN_SRC emacs-lisp
(add-to-list 'display-buffer-alist
             `("\\*pry*"
               nil
               (reusable-frames . t)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
1. first frame with a.py and b.py, second frame with the shell
2. assign to magit
3. dont open in another frame
4. it'll open in another frame
#+END_SRC

If you're curious about more options and its internals, you could see the awesome [[https://github.com/bmag/emacs-purpose/wiki/][wiki]] of the project.

* improving your workflow
Now that we have a notion of how purpose works, we can extend it to bring multiple frames to the table.

#+BEGIN_SRC 
1. three frames
2. one is code, two is magit, three is shell
3. try to open shell
4. try to open shell
#+END_SRC

Having multiple GUI windows is a disadvantage when you use a floating window manager, since ~alt-tab~ is your only friend.
But, when a lot of windows are involved, having a single method to switch among windows becomes really cumbersome.

When you introduce a tiling window manager to your life, you realize that alt-tab was in fact your enemy the whole time.
With a clean and flexible way to organize your windows, you can be really productive assigning each different window to a new keybinding.

I can't really say for other window managers, but i3wm separates the GUI windows in workspaces.
You can have as many as you want and it's common to assign workspaces as numbers.
So, if you press ~Super-x~, it'll show you the ~x~ workspace.

Let me introduce a possible setup with these workspaces:
- 1st: primary coding editor
- 2nd: secondary coding editor; useful if you use another editor
- 3rd: browser
- 4th: terminal
- 5th: email
- 6th: notes
- 7th: magit
- 8th: information about executable: compilation information or run the tests
- 9th: elfeed
  
For each one of them, we assign the windows to each frame.
Only the first and the second workspace doesn't have any purpose.
So, any buffer that's different fro the configured will be opened in these frames.
The interesting part is that you're free to pick the setup that's most suitable to you.

* open all frames automatically
Opening all these Emacs frames and assign each one to the correct workspace is a manual and repetitive task.
We need an automatic mechanism to launch and position all these frames in each correct workspace.

** Defining the frames
I'll use only the Magit workspace, but it can be extended later easily with your preferences.
This snippet basically creates all desired frames and configures them with purpose.

#+BEGIN_SRC emacs-lisp :exports result
(setq zezin-frames
      '(((title . "Emacs - Primary"))

        ((title . "Emacs - Git") 
         (start-fn . zezin-start-magit-frame))))

(use-package window-purpose
  :config
  (progn
    (purpose-mode)

    (add-to-list 'purpose-user-mode-purposes '(ruby-mode . python))
    (add-to-list 'purpose-user-regexp-purposes '("^\\*pry\\*" . magit))

    (add-to-list 'display-buffer-alist
                 `("\\*pry*"
                   nil
                   (reusable-frames . t)))

    (purpose-compile-user-configuration)))

(defun zezin-start-magit-frame (frame)
  (switch-to-buffer (get-buffer-create "*magit: purpose"))
  (purpose-toggle-window-purpose-dedicated))

(defun zezin-start-frames ()
  (interactive)
  (-each zezin-frames 'zezin-make-new-frame))

;; After the frame is being called, we call
(add-hook 'after-make-frame-functions
          (lambda (frame)
            (let* ((title (zezin-frame-title frame))
                   (start-fn (zezin-find-start-fn title)))
              (when start-fn
                (select-frame frame)
                (funcall start-fn frame)))))


#+END_SRC

First of all, we define the variable ~zezin-frames~ which contains 
the title of the X11 window and a function to be executed when it's launched.

Then, in the config section of ~use-package~, 
we declare our purposes and add the ~"\\*magit*"~ to ~display-buffer-alist~ for them to be frame-aware.

Later, we have an interactive function ~zezin-start-frames~, which is not explained here in full detail because there's a lot of boilerplate code,
but it iterates over the frames on ~zezin-frames~ and launches a new frame with the specified title.
It's important that if the frame already exists, it does not open it again.

After that, we add a function to the ~after-make-frame-functions~ hook. 
This hook identifies the frame in ~zezin-frames~ and invokes the function from the ~start-fn~ value.
In the case of magit, it'll create the dummy buffer ~*magit: purpose* and dedicate the purpose;
this Emacs window will only have magit buffers in it.

** Call it from anywhere
We have the function ~zezin-start-magit-frame~, but we can only invoke it inside Emacs.
To open all these frames in any place, we can create a ~.desktop~ file that can be called by any launcher.
I use [[https://github.com/albertlauncher/albert][Albert]] by the way, but it could really be any [[https://wiki.archlinux.org/index.php/List_of_applications#Application_launchers][launcher]]. In the end, it won't make any difference.

#+BEGIN_SRC conf :exports result
# Save it in ~/.local/share/applications/emacssetup.desktop
[Desktop Entry]
Name=Emacs Setup
Comment=Spawn specific Emacs instances
# Emacs daemon is required for this
Exec=emacsclient -c -e "(zezin-start-frames)"
Icon=emacs
#+END_SRC

** Position the frames automatically
Now we are opening all the frames specified in our list, but i3wm positions all of them in the same workspace.
By the way, remember that each frame has a different title? 
We can use this information to position each frame in the desired workspace.

#+BEGIN_SRC conf :exports result
assign [title="Emacs - Primary"] 1
assign [title="Emacs - Git"] 2
#+END_SRC

Now, after the ~Emacs Setup~ is called in our launcher application, we can press ~Win+2~ and always find the Magit frame in this workspace.
If we call ~magit-status~, it'll always open the workspace 2 with the Magit buffer.

* conclusion
I tried to present here a different way to position your buffers with Emacs.
I'm using it for a few months and it's been great.
By the way, you can use this purpose configuration with a floating window manager, 
but I don't really know if it'll be worth it.

If you're curious, my day to day usage of this feature is _here_.
